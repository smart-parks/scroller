{"version":3,"file":"index.js","sources":["src/Animate.js","src/easing.js","src/Scroller.js"],"sourcesContent":["/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\n/**\n * Generic animation class with support for dropped frames both optional easing and duration.\n *\n * Optional duration is useful when the lifetime is defined by another condition than time\n * e.g. speed of an animating object, etc.\n *\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n * based on the pure time difference.\n */\n\nconst global = typeof window == \"undefined\" ? {} : window;\n\nconst desiredFrames = 60;\nconst millisecondsPerSecond = 1000;\n\nlet running = {};\nlet counter = 1;\n\n/**\n * A requestAnimationFrame wrapper / polyfill.\n *\n * @param callback {Function} The callback to be invoked before the next repaint.\n */\nconst requestAnimationFrame =\n  global.requestAnimationFrame ||\n  global.webkitRequestAnimationFrame ||\n  global.mozRequestAnimationFrame ||\n  global.oRequestAnimationFrame;\n\n/**\n * Stops the given animation.\n *\n * @param {number} id Unique animation ID\n * @return {boolean} Whether the animation was stopped (aka, was running before)\n */\nexport function stop(id) {\n  var cleared = running[id] != null;\n\n  if (cleared) {\n    running[id] = null;\n  }\n\n  return cleared;\n}\n\n/**\n * Whether the given animation is still running.\n *\n * @param {number} id Unique animation ID\n * @return {boolean} Whether the animation is still running\n */\nexport function isRunning(id) {\n  return running[id] != null;\n}\n\n/**\n * Start the animation.\n *\n * @param {Function} stepCallback Pointer to function which is executed on every step. Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n * @param {Function} verifyCallback Executed before every animation step. Signature of the method should be `function() { return continueWithAnimation; }`\n * @param {Function} completedCallback Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n * @param {number} [duration] Milliseconds to run the animation\n * @param {Function} [easingMethod] Pointer to easing function Signature of the method should be `function(percent) { return modifiedValue; }` usage of requestAnimationFrame.\n * @return {number} Identifier of animation. Can be used to stop it any time.\n */\nexport function start(\n  stepCallback,\n  verifyCallback,\n  completedCallback,\n  duration,\n  easingMethod\n) {\n  var start = Date.now();\n  var lastFrame = start;\n  var percent = 0;\n  var dropCounter = 0;\n  var id = counter++;\n\n  // Compacting running db automatically every few new animations\n  if (id % 20 === 0) {\n    var newRunning = {};\n    for (var usedId in running) {\n      newRunning[usedId] = true;\n    }\n    running = newRunning;\n  }\n\n  // This is the internal step method which is called every few milliseconds\n  var step = function (virtual) {\n    // Normalize virtual value\n    var render = virtual !== true;\n\n    // Get current time\n    var now = Date.now();\n\n    // Verification is executed before next animation step\n    if (!running[id] || (verifyCallback && !verifyCallback(id))) {\n      running[id] = null;\n      completedCallback &&\n        completedCallback(\n          desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond),\n          id,\n          false\n        );\n      return;\n    }\n\n    // For the current rendering to apply let's update omitted steps in memory.\n    // This is important to bring internal state variables up-to-date with progress in time.\n    if (render) {\n      var droppedFrames =\n        Math.round(\n          (now - lastFrame) / (millisecondsPerSecond / desiredFrames)\n        ) - 1;\n      for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n        step(true);\n        dropCounter++;\n      }\n    }\n\n    // Compute percent value\n    if (duration) {\n      percent = (now - start) / duration;\n      if (percent > 1) {\n        percent = 1;\n      }\n    }\n\n    // Execute step callback, then...\n    var value = easingMethod ? easingMethod(percent) : percent;\n    if (\n      (stepCallback(value, now, render) === false || percent === 1) &&\n      render\n    ) {\n      running[id] = null;\n      completedCallback &&\n        completedCallback(\n          desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond),\n          id,\n          percent === 1 || duration == null\n        );\n    } else if (render) {\n      lastFrame = now;\n      requestAnimationFrame(step);\n    }\n  };\n\n  // Mark as running\n  running[id] = true;\n\n  // Init first step\n  requestAnimationFrame(step);\n\n  // Return unique animation ID\n  return id;\n}\n","// Easing Equations (c) 2003 Robert Penner, all rights reserved.\n// Open source under the BSD License.\n\n/**\n * @private\n * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n **/\nexport function easeOutCubic(pos) {\n  return Math.pow(pos - 1, 3) + 1;\n}\n\n/**\n * @private\n * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n **/\nexport function easeInOutCubic(pos) {\n  if ((pos /= 0.5) < 1) {\n    return 0.5 * Math.pow(pos, 3);\n  }\n\n  return 0.5 * (Math.pow(pos - 2, 3) + 2);\n}\n","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\nimport { start, stop } from \"./Animate.js\";\nimport { easeOutCubic, easeInOutCubic } from \"./easing.js\";\n\nfunction NOOP() {}\n\n/**\n * @public\n */\nconst defaults = {\n  /** Enable scrolling on x-axis */\n  scrollingX: true,\n\n  /** Enable scrolling on y-axis */\n  scrollingY: true,\n\n  /** Enable animations for deceleration, snap back, zooming and scrolling */\n  animating: true,\n\n  /** duration for animations triggered by scrollTo/zoomTo */\n  animationDuration: 250,\n\n  /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n  bouncing: true,\n\n  /** Enable locking to the main axis if user moves only slightly on one of them at start */\n  locking: true,\n\n  /** Enable pagination mode (switching between full page content panes) */\n  paging: false,\n\n  /** Enable snapping of content to a configured pixel grid */\n  snapping: false,\n\n  /** Enable zooming of content via API, fingers and mouse wheel */\n  zooming: false,\n\n  /** Minimum zoom level */\n  minZoom: 0.5,\n\n  /** Maximum zoom level */\n  maxZoom: 3,\n\n  /** Multiply or decrease scrolling speed **/\n  speedMultiplier: 1,\n\n  /** Callback that is fired on the later of touch end or deceleration end,\n         provided that another scrolling action has not begun. Used to know\n         when to fade out a scrollbar. */\n  scrollingComplete: NOOP,\n\n  /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n  penetrationDeceleration: 0.03,\n\n  /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n  penetrationAcceleration: 0.08,\n};\n\n/**\n * A pure logic 'component' for 'virtual' scrolling/zooming.\n * @constructor\n * @public\n */\nfunction Scroller(callback, options) {\n  this.__callback = callback;\n\n  this.options = Object.assign({}, defaults, options);\n}\n\n// Easing Equations (c) 2003 Robert Penner, all rights reserved.\n// Open source under the BSD License.\n\nScroller.prototype = {\n  /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: STATUS\n    ---------------------------------------------------------------------------\n    */\n\n  /** {Boolean} Whether only a single finger is used in touch handling */\n  __isSingleTouch: false,\n\n  /** {Boolean} Whether a touch event sequence is in progress */\n  __isTracking: false,\n\n  /** {Boolean} Whether a deceleration animation went to completion. */\n  __didDecelerationComplete: false,\n\n  /**\n   * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\n   * a gesturestart event happens. This has higher priority than dragging.\n   */\n  __isGesturing: false,\n\n  /**\n   * {Boolean} Whether the user has moved by such a distance that we have enabled\n   * dragging mode. Hint: It's only enabled after some pixels of movement to\n   * not interrupt with clicks etc.\n   */\n  __isDragging: false,\n\n  /**\n   * {Boolean} Not touching and dragging anymore, and smoothly animating the\n   * touch sequence using deceleration.\n   */\n  __isDecelerating: false,\n\n  /**\n   * {Boolean} Smoothly animating the currently configured change\n   */\n  __isAnimating: false,\n\n  /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: DIMENSIONS\n    ---------------------------------------------------------------------------\n    */\n\n  /** {Integer} Available outer left position (from document perspective) */\n  __clientLeft: 0,\n\n  /** {Integer} Available outer top position (from document perspective) */\n  __clientTop: 0,\n\n  /** {Integer} Available outer width */\n  __clientWidth: 0,\n\n  /** {Integer} Available outer height */\n  __clientHeight: 0,\n\n  /** {Integer} Outer width of content */\n  __contentWidth: 0,\n\n  /** {Integer} Outer height of content */\n  __contentHeight: 0,\n\n  /** {Integer} Snapping width for content */\n  __snapWidth: 100,\n\n  /** {Integer} Snapping height for content */\n  __snapHeight: 100,\n\n  /** {Integer} Height to assign to refresh area */\n  __refreshHeight: null,\n\n  /** {Boolean} Whether the refresh process is enabled when the event is released now */\n  __refreshActive: false,\n\n  /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n  __refreshActivate: null,\n\n  /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n  __refreshDeactivate: null,\n\n  /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n  __refreshStart: null,\n\n  /** {Number} Zoom level */\n  __zoomLevel: 1,\n\n  /** {Number} Scroll position on x-axis */\n  __scrollLeft: 0,\n\n  /** {Number} Scroll position on y-axis */\n  __scrollTop: 0,\n\n  /** {Integer} Maximum allowed scroll position on x-axis */\n  __maxScrollLeft: 0,\n\n  /** {Integer} Maximum allowed scroll position on y-axis */\n  __maxScrollTop: 0,\n\n  /* {Number} Scheduled left position (final position when animating) */\n  __scheduledLeft: 0,\n\n  /* {Number} Scheduled top position (final position when animating) */\n  __scheduledTop: 0,\n\n  /* {Number} Scheduled zoom level (final scale when animating) */\n  __scheduledZoom: 0,\n\n  /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: LAST POSITIONS\n    ---------------------------------------------------------------------------\n    */\n\n  /** {Number} Left position of finger at start */\n  __lastTouchLeft: null,\n\n  /** {Number} Top position of finger at start */\n  __lastTouchTop: null,\n\n  /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n  __lastTouchMove: null,\n\n  /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n  __positions: null,\n\n  /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: DECELERATION SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n  /** {Integer} Minimum left scroll position during deceleration */\n  __minDecelerationScrollLeft: null,\n\n  /** {Integer} Minimum top scroll position during deceleration */\n  __minDecelerationScrollTop: null,\n\n  /** {Integer} Maximum left scroll position during deceleration */\n  __maxDecelerationScrollLeft: null,\n\n  /** {Integer} Maximum top scroll position during deceleration */\n  __maxDecelerationScrollTop: null,\n\n  /** {Number} Current factor to modify horizontal scroll position with on every step */\n  __decelerationVelocityX: null,\n\n  /** {Number} Current factor to modify vertical scroll position with on every step */\n  __decelerationVelocityY: null,\n\n  /*\n    ---------------------------------------------------------------------------\n      PUBLIC API\n    ---------------------------------------------------------------------------\n    */\n\n  /**\n   * Configures the dimensions of the client (outer) and content (inner) elements.\n   * Requires the available space for the outer element and the outer size of the inner element.\n   * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n   *\n   * @public\n   *\n   * @param clientWidth {Integer ? null} Inner width of outer element\n   * @param clientHeight {Integer ? null} Inner height of outer element\n   * @param contentWidth {Integer ? null} Outer width of inner element\n   * @param contentHeight {Integer ? null} Outer height of inner element\n   */\n  setDimensions: function (\n    clientWidth,\n    clientHeight,\n    contentWidth,\n    contentHeight\n  ) {\n    var self = this;\n\n    // Only update values which are defined\n    if (clientWidth === +clientWidth) {\n      self.__clientWidth = clientWidth;\n    }\n\n    if (clientHeight === +clientHeight) {\n      self.__clientHeight = clientHeight;\n    }\n\n    if (contentWidth === +contentWidth) {\n      self.__contentWidth = contentWidth;\n    }\n\n    if (contentHeight === +contentHeight) {\n      self.__contentHeight = contentHeight;\n    }\n\n    // Refresh maximums\n    self.__computeScrollMax();\n\n    // Refresh scroll position\n    self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n  },\n\n  /**\n   * Sets the client coordinates in relation to the document.\n   *\n   * @public\n   *\n   * @param left {Integer ? 0} Left position of outer element\n   * @param top {Integer ? 0} Top position of outer element\n   */\n  setPosition: function (left, top) {\n    var self = this;\n\n    self.__clientLeft = left || 0;\n    self.__clientTop = top || 0;\n  },\n\n  /**\n   * Configures the snapping (when snapping is active)\n   *\n   * @public\n   *\n   * @param width {Integer} Snapping width\n   * @param height {Integer} Snapping height\n   */\n  setSnapSize: function (width, height) {\n    var self = this;\n\n    self.__snapWidth = width;\n    self.__snapHeight = height;\n  },\n\n  /**\n   * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n   * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n   * the official Twitter client.\n   *\n   * @public\n   *\n   * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n   * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n   * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n   * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n   */\n  activatePullToRefresh: function (\n    height,\n    activateCallback,\n    deactivateCallback,\n    startCallback\n  ) {\n    var self = this;\n\n    self.__refreshHeight = height;\n    self.__refreshActivate = activateCallback;\n    self.__refreshDeactivate = deactivateCallback;\n    self.__refreshStart = startCallback;\n  },\n\n  /**\n   * Starts pull-to-refresh manually.\n   * @public\n   */\n  triggerPullToRefresh: function () {\n    // Use publish instead of scrollTo to allow scrolling to out of boundary position\n    // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n    this.__publish(\n      this.__scrollLeft,\n      -this.__refreshHeight,\n      this.__zoomLevel,\n      true\n    );\n\n    if (this.__refreshStart) {\n      this.__refreshStart();\n    }\n  },\n\n  /**\n   * Signalizes that pull-to-refresh is finished.\n   * @public\n   */\n  finishPullToRefresh: function () {\n    var self = this;\n\n    self.__refreshActive = false;\n    if (self.__refreshDeactivate) {\n      self.__refreshDeactivate();\n    }\n\n    self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n  },\n\n  /**\n   * Returns the scroll position and zooming values\n   *\n   * @public\n   *\n   * @return {Object} `left` and `top` scroll position and `zoom` level\n   */\n  getValues: function () {\n    var self = this;\n\n    return {\n      left: self.__scrollLeft,\n      top: self.__scrollTop,\n      zoom: self.__zoomLevel,\n    };\n  },\n\n  /**\n   * Returns the maximum scroll values\n   *\n   * @public\n   *\n   * @return {Object} `left` and `top` maximum scroll values\n   */\n  getScrollMax: function () {\n    var self = this;\n\n    return {\n      left: self.__maxScrollLeft,\n      top: self.__maxScrollTop,\n    };\n  },\n\n  /**\n   * Zooms to the given level. Supports optional animation. Zooms\n   * the center when no coordinates are given.\n   *\n   * @public\n   *\n   * @param level {Number} Level to zoom to\n   * @param animate {Boolean ? false} Whether to use animation\n   * @param originLeft {Number ? null} Zoom in at given left coordinate\n   * @param originTop {Number ? null} Zoom in at given top coordinate\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n   */\n  zoomTo: function (level, animate, originLeft, originTop, callback) {\n    var self = this;\n\n    if (!self.options.zooming) {\n      throw new Error(\"Zooming is not enabled!\");\n    }\n\n    // Add callback if exists\n    if (callback) {\n      self.__zoomComplete = callback;\n    }\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    var oldLevel = self.__zoomLevel;\n\n    // Normalize input origin to center of viewport if not defined\n    if (originLeft == null) {\n      originLeft = self.__clientWidth / 2;\n    }\n\n    if (originTop == null) {\n      originTop = self.__clientHeight / 2;\n    }\n\n    // Limit level according to configuration\n    level = Math.max(\n      Math.min(level, self.options.maxZoom),\n      self.options.minZoom\n    );\n\n    // Recompute maximum values while temporary tweaking maximum scroll ranges\n    self.__computeScrollMax(level);\n\n    // Recompute left and top coordinates based on new zoom level\n    var left =\n      ((originLeft + self.__scrollLeft) * level) / oldLevel - originLeft;\n    var top = ((originTop + self.__scrollTop) * level) / oldLevel - originTop;\n\n    // Limit x-axis\n    if (left > self.__maxScrollLeft) {\n      left = self.__maxScrollLeft;\n    } else if (left < 0) {\n      left = 0;\n    }\n\n    // Limit y-axis\n    if (top > self.__maxScrollTop) {\n      top = self.__maxScrollTop;\n    } else if (top < 0) {\n      top = 0;\n    }\n\n    // Push values out\n    self.__publish(left, top, level, animate);\n  },\n\n  /**\n   * Zooms the content by the given factor.\n   *\n   * @public\n   *\n   * @param factor {Number} Zoom by given factor\n   * @param animate {Boolean ? false} Whether to use animation\n   * @param originLeft {Number ? 0} Zoom in at given left coordinate\n   * @param originTop {Number ? 0} Zoom in at given top coordinate\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n   */\n  zoomBy: function (factor, animate, originLeft, originTop, callback) {\n    var self = this;\n\n    self.zoomTo(\n      self.__zoomLevel * factor,\n      animate,\n      originLeft,\n      originTop,\n      callback\n    );\n  },\n\n  /**\n   * Scrolls to the given position. Respect limitations and snapping automatically.\n   *\n   * @public\n   *\n   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n   * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n   * @param zoom {Number?null} Zoom level to go to\n   */\n  scrollTo: function (left, top, animate, zoom) {\n    var self = this;\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    // Correct coordinates based on new zoom level\n    if (zoom != null && zoom !== self.__zoomLevel) {\n      if (!self.options.zooming) {\n        throw new Error(\"Zooming is not enabled!\");\n      }\n\n\n      left *= zoom;\n      top *= zoom;\n      // Recompute maximum values while temporary tweaking maximum scroll ranges\n      self.__computeScrollMax(zoom);\n    } else {\n      // Keep zoom when not defined\n      zoom = self.__zoomLevel;\n    }\n\n    if (!self.options.scrollingX) {\n      left = self.__scrollLeft;\n    } else {\n      if (self.options.paging) {\n        left = Math.round(left / self.__clientWidth) * self.__clientWidth;\n      } else if (self.options.snapping) {\n        left = Math.round(left / self.__snapWidth) * self.__snapWidth;\n      }\n    }\n\n    if (!self.options.scrollingY) {\n      top = self.__scrollTop;\n    } else {\n      if (self.options.paging) {\n        top = Math.round(top / self.__clientHeight) * self.__clientHeight;\n      } else if (self.options.snapping) {\n        top = Math.round(top / self.__snapHeight) * self.__snapHeight;\n      }\n    }\n\n    // Limit for allowed ranges\n    left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n    top = Math.max(Math.min(self.__maxScrollTop, top), 0);\n\n    // Don't animate when no change detected, still call publish to make sure\n    // that rendered position is really in-sync with internal data\n    if (left === self.__scrollLeft && top === self.__scrollTop) {\n      animate = false;\n    }\n\n    // Publish new values\n    if (!self.__isTracking) {\n      self.__publish(left, top, zoom, animate);\n    }\n  },\n\n  /**\n   * Scrolls to the given position, centering the position on the\n   *\n   * @public\n   *\n   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n   * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n   * @param zoom {Number?null} Zoom level to go to\n   */\n  scrollToViewportCenter(left, top, animate, zoom) {\n    zoom = zoom == null ? this.__zoomLevel : zoom\n\n    // TODO - it would be really awesome if we could animate this,\n    // however it appears to get in the way of panning.\n    this.zoomTo(zoom, false)\n\n    this.scrollTo(\n      left * zoom - this.__clientWidth * 0.5,\n      top * zoom - this.__clientHeight * 0.5,\n      animate\n    );\n  },\n\n  /**\n   * Scroll by the given offset\n   *\n   * @public\n   *\n   * @param left {Number ? 0} Scroll x-axis by given offset\n   * @param top {Number ? 0} Scroll x-axis by given offset\n   * @param animate {Boolean ? false} Whether to animate the given change\n   */\n  scrollBy: function (left, top, animate) {\n    var self = this;\n\n    var startLeft = self.__isAnimating\n      ? self.__scheduledLeft\n      : self.__scrollLeft;\n    var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n\n    self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n  },\n\n  /**\n   * Determine if a point is found within the bounds of a container\n   *\n   * @public\n   *\n   * @param x {Number} X coordinate of point\n   * @param y {Number} Y coordinate of point\n   *\n   * @returns {Boolean} True if found within container bounds\n   */\n  containsPoint(x, y) {\n    if (x < 0) {\n      return false;\n    }\n\n    if (x > self.__contentWidth) {\n      return false;\n    }\n\n    if (y < 0) {\n      return false;\n    }\n\n    if (y > self.__contentHeight) {\n      return false;\n    }\n\n    return true;\n  },\n\n  /*\n    ---------------------------------------------------------------------------\n      EVENT CALLBACKS\n    ---------------------------------------------------------------------------\n    */\n\n  /**\n   * Mouse wheel handler for zooming support\n   * @public\n   */\n  doMouseZoom: function (wheelDelta, timeStamp, pageX, pageY) {\n    var self = this;\n    var change = wheelDelta > 0 ? 0.97 : 1.03;\n\n    return self.zoomTo(\n      self.__zoomLevel * change,\n      false,\n      pageX - self.__clientLeft,\n      pageY - self.__clientTop\n    );\n  },\n\n  /**\n   * Touch start handler for scrolling support\n   * @public\n   */\n  doTouchStart: function (touches, timeStamp) {\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error(\"Invalid touch list: \" + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== \"number\") {\n      throw new Error(\"Invalid timestamp value: \" + timeStamp);\n    }\n\n    var self = this;\n\n    // Reset interruptedAnimation flag\n    self.__interruptedAnimation = true;\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Stop animation\n    if (self.__isAnimating) {\n      stop(self.__isAnimating);\n      self.__isAnimating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Use center point when dealing with two fingers\n    var currentTouchLeft, currentTouchTop;\n    var isSingleTouch = touches.length === 1;\n    if (isSingleTouch) {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    } else {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    }\n\n    // Store initial positions\n    self.__initialTouchLeft = currentTouchLeft;\n    self.__initialTouchTop = currentTouchTop;\n\n    // Store current zoom level\n    self.__zoomLevelStart = self.__zoomLevel;\n\n    // Store initial touch positions\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n\n    // Store initial move time stamp\n    self.__lastTouchMove = timeStamp;\n\n    // Reset initial scale\n    self.__lastScale = 1;\n\n    // Reset locking flags\n    self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n    self.__enableScrollY = !isSingleTouch && self.options.scrollingY;\n\n    // Reset tracking flag\n    self.__isTracking = true;\n\n    // Reset deceleration complete flag\n    self.__didDecelerationComplete = false;\n\n    // Dragging starts directly with two fingers, otherwise lazy with an offset\n    self.__isDragging = !isSingleTouch;\n\n    // Some features are disabled in multi touch scenarios\n    self.__isSingleTouch = isSingleTouch;\n\n    // Clearing data structure\n    self.__positions = [];\n  },\n\n  /**\n   * Touch move handler for scrolling support\n   * @public\n   */\n  doTouchMove: function (touches, timeStamp, scale) {\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error(\"Invalid touch list: \" + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== \"number\") {\n      throw new Error(\"Invalid timestamp value: \" + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (event might be outside of element)\n    if (!self.__isTracking) {\n      return;\n    }\n\n    var currentTouchLeft, currentTouchTop;\n\n    // Compute move based around of center of fingers\n    if (touches.length === 2) {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    } else {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    }\n\n    var positions = self.__positions;\n\n    // Are we already is dragging mode?\n    if (self.__isDragging) {\n      // Compute move distance\n      var moveX = currentTouchLeft - self.__lastTouchLeft;\n      var moveY = currentTouchTop - self.__lastTouchTop;\n\n      // Read previous scroll position and zooming\n      var scrollLeft = self.__scrollLeft;\n      var scrollTop = self.__scrollTop;\n      var level = self.__zoomLevel;\n\n      // Work with scaling\n      if (scale != null && self.options.zooming) {\n        var oldLevel = level;\n\n        // Recompute level based on previous scale and new scale\n        level = (level / self.__lastScale) * scale;\n\n        // Limit level according to configuration\n        level = Math.max(\n          Math.min(level, self.options.maxZoom),\n          self.options.minZoom\n        );\n\n        // Only do further compution when change happened\n        if (oldLevel !== level) {\n          // Compute relative event position to container\n          var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n          var currentTouchTopRel = currentTouchTop - self.__clientTop;\n\n          // Recompute left and top coordinates based on new zoom level\n          scrollLeft =\n            ((currentTouchLeftRel + scrollLeft) * level) / oldLevel -\n            currentTouchLeftRel;\n          scrollTop =\n            ((currentTouchTopRel + scrollTop) * level) / oldLevel -\n            currentTouchTopRel;\n\n          // Recompute max scroll values\n          self.__computeScrollMax(level);\n        }\n      }\n\n      if (self.__enableScrollX) {\n        scrollLeft -= moveX * this.options.speedMultiplier;\n        var maxScrollLeft = self.__maxScrollLeft;\n\n        if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n          // Slow down on the edges\n          if (self.options.bouncing) {\n            scrollLeft += (moveX / 2) * this.options.speedMultiplier;\n          } else if (scrollLeft > maxScrollLeft) {\n            scrollLeft = maxScrollLeft;\n          } else {\n            scrollLeft = 0;\n          }\n        }\n      }\n\n      // Compute new vertical scroll position\n      if (self.__enableScrollY) {\n        scrollTop -= moveY * this.options.speedMultiplier;\n        var maxScrollTop = self.__maxScrollTop;\n\n        if (scrollTop > maxScrollTop || scrollTop < 0) {\n          // Slow down on the edges\n          if (self.options.bouncing) {\n            scrollTop += (moveY / 2) * this.options.speedMultiplier;\n\n            // Support pull-to-refresh (only when only y is scrollable)\n            if (!self.__enableScrollX && self.__refreshHeight != null) {\n              if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n                self.__refreshActive = true;\n                if (self.__refreshActivate) {\n                  self.__refreshActivate();\n                }\n              } else if (\n                self.__refreshActive &&\n                scrollTop > -self.__refreshHeight\n              ) {\n                self.__refreshActive = false;\n                if (self.__refreshDeactivate) {\n                  self.__refreshDeactivate();\n                }\n              }\n            }\n          } else if (scrollTop > maxScrollTop) {\n            scrollTop = maxScrollTop;\n          } else {\n            scrollTop = 0;\n          }\n        }\n      }\n\n      // Keep list from growing infinitely (holding min 10, max 20 measure points)\n      if (positions.length > 60) {\n        positions.splice(0, 30);\n      }\n\n      // Track scroll movement for decleration\n      positions.push(scrollLeft, scrollTop, timeStamp);\n\n      // Sync scroll position\n      self.__publish(scrollLeft, scrollTop, level);\n\n      // Otherwise figure out whether we are switching into dragging mode now.\n    } else {\n      var minimumTrackingForScroll = self.options.locking ? 3 : 0;\n      var minimumTrackingForDrag = 5;\n\n      var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n      var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n\n      self.__enableScrollX =\n        self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n      self.__enableScrollY =\n        self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n\n      positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n\n      self.__isDragging =\n        (self.__enableScrollX || self.__enableScrollY) &&\n        (distanceX >= minimumTrackingForDrag ||\n          distanceY >= minimumTrackingForDrag);\n      if (self.__isDragging) {\n        self.__interruptedAnimation = false;\n      }\n    }\n\n    // Update last touch positions and time stamp for next event\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n    self.__lastTouchMove = timeStamp;\n    self.__lastScale = scale;\n  },\n\n  /**\n   * Touch end handler for scrolling support\n   * @public\n   */\n  doTouchEnd: function (timeStamp) {\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== \"number\") {\n      throw new Error(\"Invalid timestamp value: \" + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (no touchstart event on element)\n    // This is required as this listener ('touchmove') sits on the document and not on the element itself.\n    if (!self.__isTracking) {\n      return;\n    }\n\n    // Not touching anymore (when two finger hit the screen there are two touch end events)\n    self.__isTracking = false;\n\n    // Be sure to reset the dragging flag now. Here we also detect whether\n    // the finger has moved fast enough to switch into a deceleration animation.\n    if (self.__isDragging) {\n      // Reset dragging flag\n      self.__isDragging = false;\n\n      // Start deceleration\n      // Verify that the last move detected was in some relevant time frame\n      if (\n        self.__isSingleTouch &&\n        self.options.animating &&\n        timeStamp - self.__lastTouchMove <= 100\n      ) {\n        // Then figure out what the scroll position was about 100ms ago\n        var positions = self.__positions;\n        var endPos = positions.length - 1;\n        var startPos = endPos;\n\n        // Move pointer to position measured 100ms ago\n        for (\n          var i = endPos;\n          i > 0 && positions[i] > self.__lastTouchMove - 100;\n          i -= 3\n        ) {\n          startPos = i;\n        }\n\n        // If start and stop position is identical in a 100ms timeframe,\n        // we cannot compute any useful deceleration.\n        if (startPos !== endPos) {\n          // Compute relative movement between these two points\n          var timeOffset = positions[endPos] - positions[startPos];\n          var movedLeft = self.__scrollLeft - positions[startPos - 2];\n          var movedTop = self.__scrollTop - positions[startPos - 1];\n\n          // Based on 50ms compute the movement to apply for each render step\n          self.__decelerationVelocityX = (movedLeft / timeOffset) * (1000 / 60);\n          self.__decelerationVelocityY = (movedTop / timeOffset) * (1000 / 60);\n\n          // How much velocity is required to start the deceleration\n          var minVelocityToStartDeceleration =\n            self.options.paging || self.options.snapping ? 4 : 1;\n\n          // Verify that we have enough velocity to start deceleration\n          if (\n            Math.abs(self.__decelerationVelocityX) >\n              minVelocityToStartDeceleration ||\n            Math.abs(self.__decelerationVelocityY) >\n              minVelocityToStartDeceleration\n          ) {\n            // Deactivate pull-to-refresh when decelerating\n            if (!self.__refreshActive) {\n              self.__startDeceleration(timeStamp);\n            }\n          } else {\n            self.options.scrollingComplete();\n          }\n        } else {\n          self.options.scrollingComplete();\n        }\n      } else if (timeStamp - self.__lastTouchMove > 100) {\n        self.options.scrollingComplete();\n      }\n    }\n\n    // If this was a slower move it is per default non decelerated, but this\n    // still means that we want snap back to the bounds which is done here.\n    // This is placed outside the condition above to improve edge case stability\n    // e.g. touchend fired without enabled dragging. This should normally do not\n    // have modified the scroll positions or even showed the scrollbars though.\n    if (!self.__isDecelerating) {\n      if (self.__refreshActive && self.__refreshStart) {\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n        self.__publish(\n          self.__scrollLeft,\n          -self.__refreshHeight,\n          self.__zoomLevel,\n          true\n        );\n\n        if (self.__refreshStart) {\n          self.__refreshStart();\n        }\n      } else {\n        if (self.__interruptedAnimation || self.__isDragging) {\n          self.options.scrollingComplete();\n        }\n        self.scrollTo(\n          self.__scrollLeft,\n          self.__scrollTop,\n          true,\n          self.__zoomLevel\n        );\n\n        // Directly signalize deactivation (nothing todo on refresh?)\n        if (self.__refreshActive) {\n          self.__refreshActive = false;\n          if (self.__refreshDeactivate) {\n            self.__refreshDeactivate();\n          }\n        }\n      }\n    }\n\n    // Fully cleanup list\n    self.__positions.length = 0;\n  },\n\n  /*\n    ---------------------------------------------------------------------------\n      PRIVATE API\n    ---------------------------------------------------------------------------\n    */\n\n  /**\n   * Applies the scroll position to the content element\n   *\n   * @private\n   *\n   * @param left {Number} Left scroll position\n   * @param top {Number} Top scroll position\n   * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\n   */\n  __publish: function (left, top, zoom, animate) {\n    var self = this;\n\n    // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n    var wasAnimating = self.__isAnimating;\n    if (wasAnimating) {\n      stop(wasAnimating);\n      self.__isAnimating = false;\n    }\n\n    if (animate && self.options.animating) {\n      // Keep scheduled positions for scrollBy/zoomBy functionality\n      self.__scheduledLeft = left;\n      self.__scheduledTop = top;\n      self.__scheduledZoom = zoom;\n\n      var oldLeft = self.__scrollLeft;\n      var oldTop = self.__scrollTop;\n      var oldZoom = self.__zoomLevel;\n\n      var diffLeft = left - oldLeft;\n      var diffTop = top - oldTop;\n      var diffZoom = zoom - oldZoom;\n\n      var step = function (percent, now, render) {\n        if (render) {\n          self.__scrollLeft = oldLeft + diffLeft * percent;\n          self.__scrollTop = oldTop + diffTop * percent;\n          self.__zoomLevel = oldZoom + diffZoom * percent;\n\n          // Push values out\n          if (self.__callback) {\n            self.__callback(\n              self.__scrollLeft,\n              self.__scrollTop,\n              self.__zoomLevel\n            );\n          }\n        }\n      };\n\n      var verify = function (id) {\n        return self.__isAnimating === id;\n      };\n\n      var completed = function (\n        renderedFramesPerSecond,\n        animationId,\n        wasFinished\n      ) {\n        if (animationId === self.__isAnimating) {\n          self.__isAnimating = false;\n        }\n        if (self.__didDecelerationComplete || wasFinished) {\n          self.options.scrollingComplete();\n        }\n\n        if (self.options.zooming) {\n          self.__computeScrollMax();\n          if (self.__zoomComplete) {\n            self.__zoomComplete();\n            self.__zoomComplete = null;\n          }\n        }\n      };\n\n      // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n      self.__isAnimating = start(\n        step,\n        verify,\n        completed,\n        self.options.animationDuration,\n        wasAnimating ? easeOutCubic : easeInOutCubic\n      );\n    } else {\n      self.__scheduledLeft = self.__scrollLeft = left;\n      self.__scheduledTop = self.__scrollTop = top;\n      self.__scheduledZoom = self.__zoomLevel = zoom;\n\n      // Push values out\n      if (self.__callback) {\n        self.__callback(left, top, zoom);\n      }\n\n      // Fix max scroll ranges\n      if (self.options.zooming) {\n        self.__computeScrollMax();\n        if (self.__zoomComplete) {\n          self.__zoomComplete();\n          self.__zoomComplete = null;\n        }\n      }\n    }\n  },\n\n  /**\n   * Recomputes scroll minimum values based on client dimensions and content dimensions.\n   * @private\n   */\n  __computeScrollMax: function (zoomLevel) {\n    var self = this;\n\n    if (zoomLevel == null) {\n      zoomLevel = self.__zoomLevel;\n    }\n\n    self.__maxScrollLeft = Math.max(\n      self.__contentWidth * zoomLevel - self.__clientWidth,\n      0\n    );\n    self.__maxScrollTop = Math.max(\n      self.__contentHeight * zoomLevel - self.__clientHeight,\n      0\n    );\n  },\n\n  /*\n    ---------------------------------------------------------------------------\n      ANIMATION (DECELERATION) SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n  /**\n   * Called when a touch sequence end and the speed of the finger was high enough\n   * to switch into deceleration mode.\n   * @private\n   */\n  __startDeceleration: function (timeStamp) {\n    var self = this;\n\n    if (self.options.paging) {\n      var scrollLeft = Math.max(\n        Math.min(self.__scrollLeft, self.__maxScrollLeft),\n        0\n      );\n      var scrollTop = Math.max(\n        Math.min(self.__scrollTop, self.__maxScrollTop),\n        0\n      );\n      var clientWidth = self.__clientWidth;\n      var clientHeight = self.__clientHeight;\n\n      // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n      // Each page should have exactly the size of the client area.\n      self.__minDecelerationScrollLeft =\n        Math.floor(scrollLeft / clientWidth) * clientWidth;\n      self.__minDecelerationScrollTop =\n        Math.floor(scrollTop / clientHeight) * clientHeight;\n      self.__maxDecelerationScrollLeft =\n        Math.ceil(scrollLeft / clientWidth) * clientWidth;\n      self.__maxDecelerationScrollTop =\n        Math.ceil(scrollTop / clientHeight) * clientHeight;\n    } else {\n      self.__minDecelerationScrollLeft = 0;\n      self.__minDecelerationScrollTop = 0;\n      self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n      self.__maxDecelerationScrollTop = self.__maxScrollTop;\n    }\n\n    // Wrap class method\n    var step = function (percent, now, render) {\n      self.__stepThroughDeceleration(render);\n    };\n\n    // How much velocity is required to keep the deceleration running\n    var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\n\n    // Detect whether it's still worth to continue animating steps\n    // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n    var verify = function () {\n      var shouldContinue =\n        Math.abs(self.__decelerationVelocityX) >=\n          minVelocityToKeepDecelerating ||\n        Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\n      if (!shouldContinue) {\n        self.__didDecelerationComplete = true;\n      }\n      return shouldContinue;\n    };\n\n    var completed = function (\n      renderedFramesPerSecond,\n      animationId,\n      wasFinished\n    ) {\n      self.__isDecelerating = false;\n      if (self.__didDecelerationComplete) {\n        self.options.scrollingComplete();\n      }\n\n      // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n    };\n\n    // Start animation and switch on flag\n    self.__isDecelerating = start(step, verify, completed);\n  },\n\n  /**\n   * Called on every step of the animation\n   *\n   * @param {Function} [render] Whether to not render the current step, but keep it in memory only. Used internally only!\n   * @private\n   */\n  __stepThroughDeceleration: function (render) {\n    var self = this;\n\n    //\n    // COMPUTE NEXT SCROLL POSITION\n    //\n\n    // Add deceleration to scroll position\n    var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n    var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\n    //\n    // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n    //\n\n    if (!self.options.bouncing) {\n      var scrollLeftFixed = Math.max(\n        Math.min(self.__maxDecelerationScrollLeft, scrollLeft),\n        self.__minDecelerationScrollLeft\n      );\n      if (scrollLeftFixed !== scrollLeft) {\n        scrollLeft = scrollLeftFixed;\n        self.__decelerationVelocityX = 0;\n      }\n\n      var scrollTopFixed = Math.max(\n        Math.min(self.__maxDecelerationScrollTop, scrollTop),\n        self.__minDecelerationScrollTop\n      );\n      if (scrollTopFixed !== scrollTop) {\n        scrollTop = scrollTopFixed;\n        self.__decelerationVelocityY = 0;\n      }\n    }\n\n    //\n    // UPDATE SCROLL POSITION\n    //\n\n    if (render) {\n      self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n    } else {\n      self.__scrollLeft = scrollLeft;\n      self.__scrollTop = scrollTop;\n    }\n\n    //\n    // SLOW DOWN\n    //\n\n    // Slow down velocity on every iteration\n    if (!self.options.paging) {\n      // This is the factor applied to every iteration of the animation\n      // to slow down the process. This should emulate natural behavior where\n      // objects slow down when the initiator of the movement is removed\n      var frictionFactor = 0.95;\n\n      self.__decelerationVelocityX *= frictionFactor;\n      self.__decelerationVelocityY *= frictionFactor;\n    }\n\n    //\n    // BOUNCING SUPPORT\n    //\n\n    if (self.options.bouncing) {\n      var scrollOutsideX = 0;\n      var scrollOutsideY = 0;\n\n      // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n      var penetrationDeceleration = self.options.penetrationDeceleration;\n      var penetrationAcceleration = self.options.penetrationAcceleration;\n\n      // Check limits\n      if (scrollLeft < self.__minDecelerationScrollLeft) {\n        scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n      } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n        scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n      }\n\n      if (scrollTop < self.__minDecelerationScrollTop) {\n        scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n      } else if (scrollTop > self.__maxDecelerationScrollTop) {\n        scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n      }\n\n      // Slow down until slow enough, then flip back to snap position\n      if (scrollOutsideX !== 0) {\n        if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n          self.__decelerationVelocityX +=\n            scrollOutsideX * penetrationDeceleration;\n        } else {\n          self.__decelerationVelocityX =\n            scrollOutsideX * penetrationAcceleration;\n        }\n      }\n\n      if (scrollOutsideY !== 0) {\n        if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n          self.__decelerationVelocityY +=\n            scrollOutsideY * penetrationDeceleration;\n        } else {\n          self.__decelerationVelocityY =\n            scrollOutsideY * penetrationAcceleration;\n        }\n      }\n    }\n  },\n};\n\nexport default Scroller;\n"],"names":["global","window","running","counter","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","stop","id","cleared","start","stepCallback","verifyCallback","completedCallback","duration","easingMethod","Date","now","lastFrame","percent","dropCounter","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","value","easeOutCubic","pos","pow","easeInOutCubic","defaults","scrollingX","scrollingY","animating","animationDuration","bouncing","locking","paging","snapping","zooming","minZoom","maxZoom","speedMultiplier","scrollingComplete","penetrationDeceleration","penetrationAcceleration","Scroller","callback","options","this","__callback","Object","assign","prototype","i","h","s","o","l","u","_","v","M","m","p","g","T","D","S","L","Z","I","P","A","H","V","C","R","W","k","B","X","Y","G","O","q","F","J","K","N","U","setDimensions","clientWidth","clientHeight","contentWidth","contentHeight","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__computeScrollMax","scrollTo","__scrollLeft","__scrollTop","setPosition","left","top","__clientLeft","__clientTop","setSnapSize","width","height","__snapWidth","__snapHeight","activatePullToRefresh","activateCallback","deactivateCallback","startCallback","__refreshHeight","__refreshActivate","__refreshDeactivate","__refreshStart","triggerPullToRefresh","__publish","__zoomLevel","finishPullToRefresh","__refreshActive","getValues","zoom","getScrollMax","__maxScrollLeft","__maxScrollTop","zoomTo","level","animate","originLeft","originTop","Error","__zoomComplete","__isDecelerating","oldLevel","max","zoomBy","factor","__isTracking","[object Object]","scrollBy","startLeft","__isAnimating","__scheduledLeft","startTop","__scheduledTop","containsPoint","x","y","self","doMouseZoom","wheelDelta","timeStamp","pageX","pageY","change","doTouchStart","touches","length","valueOf","currentTouchLeft","currentTouchTop","__interruptedAnimation","isSingleTouch","abs","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__lastScale","__enableScrollX","__enableScrollY","__didDecelerationComplete","__isDragging","__isSingleTouch","__positions","doTouchMove","scale","positions","moveX","moveY","scrollLeft","scrollTop","currentTouchLeftRel","currentTouchTopRel","maxScrollLeft","maxScrollTop","splice","push","minimumTrackingForScroll","distanceX","distanceY","doTouchEnd","endPos","startPos","timeOffset","movedLeft","movedTop","__decelerationVelocityX","__decelerationVelocityY","minVelocityToStartDeceleration","__startDeceleration","tt","wasAnimating","__scheduledZoom","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","renderedFramesPerSecond","animationId","wasFinished","$","zoomLevel","at","__minDecelerationScrollLeft","floor","__minDecelerationScrollTop","__maxDecelerationScrollLeft","ceil","__maxDecelerationScrollTop","minVelocityToKeepDecelerating","__stepThroughDeceleration","shouldContinue","ut","scrollLeftFixed","scrollTopFixed","scrollOutsideX","scrollOutsideY"],"mappings":"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"}
{"version":3,"file":"index.es.js","sources":["src/Animate.js","src/Scroller.js"],"sourcesContent":["/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\n/**\n * Generic animation class with support for dropped frames both optional easing and duration.\n *\n * Optional duration is useful when the lifetime is defined by another condition than time\n * e.g. speed of an animating object, etc.\n *\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n * based on the pure time difference.\n */\n\nconst global = typeof window == \"undefined\" ? {} : window;\n\nconst desiredFrames = 60;\nconst millisecondsPerSecond = 1000;\nconst running = {};\n\nlet counter = 1;\n\n/**\n * A requestAnimationFrame wrapper / polyfill.\n *\n * @param callback {Function} The callback to be invoked before the next repaint.\n */\nconst requestAnimationFrame =\n  global.requestAnimationFrame ||\n  global.webkitRequestAnimationFrame ||\n  global.mozRequestAnimationFrame ||\n  global.oRequestAnimationFrame;\n\n/**\n * Stops the given animation.\n *\n * @param {number} id Unique animation ID\n * @return {boolean} Whether the animation was stopped (aka, was running before)\n */\nexport function stop(id) {\n  var cleared = running[id] != null;\n\n  if (cleared) {\n    running[id] = null;\n  }\n\n  return cleared;\n}\n\n/**\n * Whether the given animation is still running.\n *\n * @param {number} id Unique animation ID\n * @return {boolean} Whether the animation is still running\n */\nexport function isRunning(id) {\n  return running[id] != null;\n}\n\n/**\n * Start the animation.\n *\n * @param {Function} stepCallback Pointer to function which is executed on every step. Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n * @param {Function} verifyCallback Executed before every animation step. Signature of the method should be `function() { return continueWithAnimation; }`\n * @param {Function} completedCallback Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n * @param {number} [duration] Milliseconds to run the animation\n * @param {Function} [easingMethod] Pointer to easing function Signature of the method should be `function(percent) { return modifiedValue; }` usage of requestAnimationFrame.\n * @return {number} Identifier of animation. Can be used to stop it any time.\n */\nexport function start(\n  stepCallback,\n  verifyCallback,\n  completedCallback,\n  duration,\n  easingMethod\n) {\n  var start = Date.now();\n  var lastFrame = start;\n  var percent = 0;\n  var dropCounter = 0;\n  var id = counter++;\n\n  // Compacting running db automatically every few new animations\n  if (id % 20 === 0) {\n    var newRunning = {};\n    for (var usedId in running) {\n      newRunning[usedId] = true;\n    }\n    running = newRunning;\n  }\n\n  // This is the internal step method which is called every few milliseconds\n  var step = function (virtual) {\n    // Normalize virtual value\n    var render = virtual !== true;\n\n    // Get current time\n    var now = Date.now();\n\n    // Verification is executed before next animation step\n    if (!running[id] || (verifyCallback && !verifyCallback(id))) {\n      running[id] = null;\n      completedCallback &&\n        completedCallback(\n          desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond),\n          id,\n          false\n        );\n      return;\n    }\n\n    // For the current rendering to apply let's update omitted steps in memory.\n    // This is important to bring internal state variables up-to-date with progress in time.\n    if (render) {\n      var droppedFrames =\n        Math.round(\n          (now - lastFrame) / (millisecondsPerSecond / desiredFrames)\n        ) - 1;\n      for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n        step(true);\n        dropCounter++;\n      }\n    }\n\n    // Compute percent value\n    if (duration) {\n      percent = (now - start) / duration;\n      if (percent > 1) {\n        percent = 1;\n      }\n    }\n\n    // Execute step callback, then...\n    var value = easingMethod ? easingMethod(percent) : percent;\n    if (\n      (stepCallback(value, now, render) === false || percent === 1) &&\n      render\n    ) {\n      running[id] = null;\n      completedCallback &&\n        completedCallback(\n          desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond),\n          id,\n          percent === 1 || duration == null\n        );\n    } else if (render) {\n      lastFrame = now;\n      requestAnimationFrame(step);\n    }\n  };\n\n  // Mark as running\n  running[id] = true;\n\n  // Init first step\n  requestAnimationFrame(step);\n\n  // Return unique animation ID\n  return id;\n}\n","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\nimport { start, stop } from \"./Animate.js\";\n\nvar Scroller;\n\n/**\n * @private\n * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n **/\nfunction easeOutCubic(pos) {\n  return Math.pow(pos - 1, 3) + 1;\n}\n\n/**\n * @private\n * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n **/\nfunction easeInOutCubic(pos) {\n  if ((pos /= 0.5) < 1) {\n    return 0.5 * Math.pow(pos, 3);\n  }\n\n  return 0.5 * (Math.pow(pos - 2, 3) + 2);\n}\n\nfunction NOOP() {}\n\n/**\n * @public\n */\nconst defaults = {\n  /** Enable scrolling on x-axis */\n  scrollingX: true,\n\n  /** Enable scrolling on y-axis */\n  scrollingY: true,\n\n  /** Enable animations for deceleration, snap back, zooming and scrolling */\n  animating: true,\n\n  /** duration for animations triggered by scrollTo/zoomTo */\n  animationDuration: 250,\n\n  /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n  bouncing: true,\n\n  /** Enable locking to the main axis if user moves only slightly on one of them at start */\n  locking: true,\n\n  /** Enable pagination mode (switching between full page content panes) */\n  paging: false,\n\n  /** Enable snapping of content to a configured pixel grid */\n  snapping: false,\n\n  /** Enable zooming of content via API, fingers and mouse wheel */\n  zooming: false,\n\n  /** Minimum zoom level */\n  minZoom: 0.5,\n\n  /** Maximum zoom level */\n  maxZoom: 3,\n\n  /** Multiply or decrease scrolling speed **/\n  speedMultiplier: 1,\n\n  /** Callback that is fired on the later of touch end or deceleration end,\n         provided that another scrolling action has not begun. Used to know\n         when to fade out a scrollbar. */\n  scrollingComplete: NOOP,\n\n  /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n  penetrationDeceleration: 0.03,\n\n  /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n  penetrationAcceleration: 0.08,\n};\n\n(function () {\n  /**\n   * A pure logic 'component' for 'virtual' scrolling/zooming.\n   * @constructor\n   * @public\n   */\n  Scroller = function (callback, options) {\n    this.__callback = callback;\n\n    this.options = Object.assign({}, defaults, options);\n  };\n\n  // Easing Equations (c) 2003 Robert Penner, all rights reserved.\n  // Open source under the BSD License.\n\n  var members = {\n    /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: STATUS\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Boolean} Whether only a single finger is used in touch handling */\n    __isSingleTouch: false,\n\n    /** {Boolean} Whether a touch event sequence is in progress */\n    __isTracking: false,\n\n    /** {Boolean} Whether a deceleration animation went to completion. */\n    __didDecelerationComplete: false,\n\n    /**\n     * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\n     * a gesturestart event happens. This has higher priority than dragging.\n     */\n    __isGesturing: false,\n\n    /**\n     * {Boolean} Whether the user has moved by such a distance that we have enabled\n     * dragging mode. Hint: It's only enabled after some pixels of movement to\n     * not interrupt with clicks etc.\n     */\n    __isDragging: false,\n\n    /**\n     * {Boolean} Not touching and dragging anymore, and smoothly animating the\n     * touch sequence using deceleration.\n     */\n    __isDecelerating: false,\n\n    /**\n     * {Boolean} Smoothly animating the currently configured change\n     */\n    __isAnimating: false,\n\n    /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: DIMENSIONS\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Integer} Available outer left position (from document perspective) */\n    __clientLeft: 0,\n\n    /** {Integer} Available outer top position (from document perspective) */\n    __clientTop: 0,\n\n    /** {Integer} Available outer width */\n    __clientWidth: 0,\n\n    /** {Integer} Available outer height */\n    __clientHeight: 0,\n\n    /** {Integer} Outer width of content */\n    __contentWidth: 0,\n\n    /** {Integer} Outer height of content */\n    __contentHeight: 0,\n\n    /** {Integer} Snapping width for content */\n    __snapWidth: 100,\n\n    /** {Integer} Snapping height for content */\n    __snapHeight: 100,\n\n    /** {Integer} Height to assign to refresh area */\n    __refreshHeight: null,\n\n    /** {Boolean} Whether the refresh process is enabled when the event is released now */\n    __refreshActive: false,\n\n    /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n    __refreshActivate: null,\n\n    /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n    __refreshDeactivate: null,\n\n    /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n    __refreshStart: null,\n\n    /** {Number} Zoom level */\n    __zoomLevel: 1,\n\n    /** {Number} Scroll position on x-axis */\n    __scrollLeft: 0,\n\n    /** {Number} Scroll position on y-axis */\n    __scrollTop: 0,\n\n    /** {Integer} Maximum allowed scroll position on x-axis */\n    __maxScrollLeft: 0,\n\n    /** {Integer} Maximum allowed scroll position on y-axis */\n    __maxScrollTop: 0,\n\n    /* {Number} Scheduled left position (final position when animating) */\n    __scheduledLeft: 0,\n\n    /* {Number} Scheduled top position (final position when animating) */\n    __scheduledTop: 0,\n\n    /* {Number} Scheduled zoom level (final scale when animating) */\n    __scheduledZoom: 0,\n\n    /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: LAST POSITIONS\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Number} Left position of finger at start */\n    __lastTouchLeft: null,\n\n    /** {Number} Top position of finger at start */\n    __lastTouchTop: null,\n\n    /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n    __lastTouchMove: null,\n\n    /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n    __positions: null,\n\n    /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: DECELERATION SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Integer} Minimum left scroll position during deceleration */\n    __minDecelerationScrollLeft: null,\n\n    /** {Integer} Minimum top scroll position during deceleration */\n    __minDecelerationScrollTop: null,\n\n    /** {Integer} Maximum left scroll position during deceleration */\n    __maxDecelerationScrollLeft: null,\n\n    /** {Integer} Maximum top scroll position during deceleration */\n    __maxDecelerationScrollTop: null,\n\n    /** {Number} Current factor to modify horizontal scroll position with on every step */\n    __decelerationVelocityX: null,\n\n    /** {Number} Current factor to modify vertical scroll position with on every step */\n    __decelerationVelocityY: null,\n\n    /*\n    ---------------------------------------------------------------------------\n      PUBLIC API\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Configures the dimensions of the client (outer) and content (inner) elements.\n     * Requires the available space for the outer element and the outer size of the inner element.\n     * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n     *\n     * @public\n     *\n     * @param clientWidth {Integer ? null} Inner width of outer element\n     * @param clientHeight {Integer ? null} Inner height of outer element\n     * @param contentWidth {Integer ? null} Outer width of inner element\n     * @param contentHeight {Integer ? null} Outer height of inner element\n     */\n    setDimensions: function (\n      clientWidth,\n      clientHeight,\n      contentWidth,\n      contentHeight\n    ) {\n      var self = this;\n\n      // Only update values which are defined\n      if (clientWidth === +clientWidth) {\n        self.__clientWidth = clientWidth;\n      }\n\n      if (clientHeight === +clientHeight) {\n        self.__clientHeight = clientHeight;\n      }\n\n      if (contentWidth === +contentWidth) {\n        self.__contentWidth = contentWidth;\n      }\n\n      if (contentHeight === +contentHeight) {\n        self.__contentHeight = contentHeight;\n      }\n\n      // Refresh maximums\n      self.__computeScrollMax();\n\n      // Refresh scroll position\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    },\n\n    /**\n     * Sets the client coordinates in relation to the document.\n     *\n     * @public\n     *\n     * @param left {Integer ? 0} Left position of outer element\n     * @param top {Integer ? 0} Top position of outer element\n     */\n    setPosition: function (left, top) {\n      var self = this;\n\n      self.__clientLeft = left || 0;\n      self.__clientTop = top || 0;\n    },\n\n    /**\n     * Configures the snapping (when snapping is active)\n     *\n     * @public\n     *\n     * @param width {Integer} Snapping width\n     * @param height {Integer} Snapping height\n     */\n    setSnapSize: function (width, height) {\n      var self = this;\n\n      self.__snapWidth = width;\n      self.__snapHeight = height;\n    },\n\n    /**\n     * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n     * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n     * the official Twitter client.\n     *\n     * @public\n     *\n     * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n     * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n     * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n     * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n     */\n    activatePullToRefresh: function (\n      height,\n      activateCallback,\n      deactivateCallback,\n      startCallback\n    ) {\n      var self = this;\n\n      self.__refreshHeight = height;\n      self.__refreshActivate = activateCallback;\n      self.__refreshDeactivate = deactivateCallback;\n      self.__refreshStart = startCallback;\n    },\n\n    /**\n     * Starts pull-to-refresh manually.\n     * @public\n     */\n    triggerPullToRefresh: function () {\n      // Use publish instead of scrollTo to allow scrolling to out of boundary position\n      // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n      this.__publish(\n        this.__scrollLeft,\n        -this.__refreshHeight,\n        this.__zoomLevel,\n        true\n      );\n\n      if (this.__refreshStart) {\n        this.__refreshStart();\n      }\n    },\n\n    /**\n     * Signalizes that pull-to-refresh is finished.\n     * @public\n     */\n    finishPullToRefresh: function () {\n      var self = this;\n\n      self.__refreshActive = false;\n      if (self.__refreshDeactivate) {\n        self.__refreshDeactivate();\n      }\n\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    },\n\n    /**\n     * Returns the scroll position and zooming values\n     *\n     * @public\n     *\n     * @return {Object} `left` and `top` scroll position and `zoom` level\n     */\n    getValues: function () {\n      var self = this;\n\n      return {\n        left: self.__scrollLeft,\n        top: self.__scrollTop,\n        zoom: self.__zoomLevel,\n      };\n    },\n\n    /**\n     * Returns the maximum scroll values\n     *\n     * @public\n     *\n     * @return {Object} `left` and `top` maximum scroll values\n     */\n    getScrollMax: function () {\n      var self = this;\n\n      return {\n        left: self.__maxScrollLeft,\n        top: self.__maxScrollTop,\n      };\n    },\n\n    /**\n     * Zooms to the given level. Supports optional animation. Zooms\n     * the center when no coordinates are given.\n     *\n     * @public\n     *\n     * @param level {Number} Level to zoom to\n     * @param animate {Boolean ? false} Whether to use animation\n     * @param originLeft {Number ? null} Zoom in at given left coordinate\n     * @param originTop {Number ? null} Zoom in at given top coordinate\n     * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n     */\n    zoomTo: function (level, animate, originLeft, originTop, callback) {\n      var self = this;\n\n      if (!self.options.zooming) {\n        throw new Error(\"Zooming is not enabled!\");\n      }\n\n      // Add callback if exists\n      if (callback) {\n        self.__zoomComplete = callback;\n      }\n\n      // Stop deceleration\n      if (self.__isDecelerating) {\n        stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n      }\n\n      var oldLevel = self.__zoomLevel;\n\n      // Normalize input origin to center of viewport if not defined\n      if (originLeft == null) {\n        originLeft = self.__clientWidth / 2;\n      }\n\n      if (originTop == null) {\n        originTop = self.__clientHeight / 2;\n      }\n\n      // Limit level according to configuration\n      level = Math.max(\n        Math.min(level, self.options.maxZoom),\n        self.options.minZoom\n      );\n\n      // Recompute maximum values while temporary tweaking maximum scroll ranges\n      self.__computeScrollMax(level);\n\n      // Recompute left and top coordinates based on new zoom level\n      var left =\n        ((originLeft + self.__scrollLeft) * level) / oldLevel - originLeft;\n      var top = ((originTop + self.__scrollTop) * level) / oldLevel - originTop;\n\n      // Limit x-axis\n      if (left > self.__maxScrollLeft) {\n        left = self.__maxScrollLeft;\n      } else if (left < 0) {\n        left = 0;\n      }\n\n      // Limit y-axis\n      if (top > self.__maxScrollTop) {\n        top = self.__maxScrollTop;\n      } else if (top < 0) {\n        top = 0;\n      }\n\n      // Push values out\n      self.__publish(left, top, level, animate);\n    },\n\n    /**\n     * Zooms the content by the given factor.\n     *\n     * @public\n     *\n     * @param factor {Number} Zoom by given factor\n     * @param animate {Boolean ? false} Whether to use animation\n     * @param originLeft {Number ? 0} Zoom in at given left coordinate\n     * @param originTop {Number ? 0} Zoom in at given top coordinate\n     * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n     */\n    zoomBy: function (factor, animate, originLeft, originTop, callback) {\n      var self = this;\n\n      self.zoomTo(\n        self.__zoomLevel * factor,\n        animate,\n        originLeft,\n        originTop,\n        callback\n      );\n    },\n\n    /**\n     * Scrolls to the given position. Respect limitations and snapping automatically.\n     *\n     * @public\n     *\n     * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n     * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n     * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n     * @param zoom {Number?null} Zoom level to go to\n     */\n    scrollTo: function (left, top, animate, zoom) {\n      var self = this;\n\n      // Stop deceleration\n      if (self.__isDecelerating) {\n        stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n      }\n\n      // Correct coordinates based on new zoom level\n      if (zoom != null && zoom !== self.__zoomLevel) {\n        if (!self.options.zooming) {\n          throw new Error(\"Zooming is not enabled!\");\n        }\n\n        left *= zoom;\n        top *= zoom;\n\n        // Recompute maximum values while temporary tweaking maximum scroll ranges\n        self.__computeScrollMax(zoom);\n      } else {\n        // Keep zoom when not defined\n        zoom = self.__zoomLevel;\n      }\n\n      if (!self.options.scrollingX) {\n        left = self.__scrollLeft;\n      } else {\n        if (self.options.paging) {\n          left = Math.round(left / self.__clientWidth) * self.__clientWidth;\n        } else if (self.options.snapping) {\n          left = Math.round(left / self.__snapWidth) * self.__snapWidth;\n        }\n      }\n\n      if (!self.options.scrollingY) {\n        top = self.__scrollTop;\n      } else {\n        if (self.options.paging) {\n          top = Math.round(top / self.__clientHeight) * self.__clientHeight;\n        } else if (self.options.snapping) {\n          top = Math.round(top / self.__snapHeight) * self.__snapHeight;\n        }\n      }\n\n      // Limit for allowed ranges\n      left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n      top = Math.max(Math.min(self.__maxScrollTop, top), 0);\n\n      // Don't animate when no change detected, still call publish to make sure\n      // that rendered position is really in-sync with internal data\n      if (left === self.__scrollLeft && top === self.__scrollTop) {\n        animate = false;\n      }\n\n      // Publish new values\n      if (!self.__isTracking) {\n        self.__publish(left, top, zoom, animate);\n      }\n    },\n\n    /**\n     * Scroll by the given offset\n     *\n     * @public\n     *\n     * @param left {Number ? 0} Scroll x-axis by given offset\n     * @param top {Number ? 0} Scroll x-axis by given offset\n     * @param animate {Boolean ? false} Whether to animate the given change\n     */\n    scrollBy: function (left, top, animate) {\n      var self = this;\n\n      var startLeft = self.__isAnimating\n        ? self.__scheduledLeft\n        : self.__scrollLeft;\n      var startTop = self.__isAnimating\n        ? self.__scheduledTop\n        : self.__scrollTop;\n\n      self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT CALLBACKS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Mouse wheel handler for zooming support\n     * @public\n     */\n    doMouseZoom: function (wheelDelta, timeStamp, pageX, pageY) {\n      var self = this;\n      var change = wheelDelta > 0 ? 0.97 : 1.03;\n\n      return self.zoomTo(\n        self.__zoomLevel * change,\n        false,\n        pageX - self.__clientLeft,\n        pageY - self.__clientTop\n      );\n    },\n\n    /**\n     * Touch start handler for scrolling support\n     * @public\n     */\n    doTouchStart: function (touches, timeStamp) {\n      // Array-like check is enough here\n      if (touches.length == null) {\n        throw new Error(\"Invalid touch list: \" + touches);\n      }\n\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n      if (typeof timeStamp !== \"number\") {\n        throw new Error(\"Invalid timestamp value: \" + timeStamp);\n      }\n\n      var self = this;\n\n      // Reset interruptedAnimation flag\n      self.__interruptedAnimation = true;\n\n      // Stop deceleration\n      if (self.__isDecelerating) {\n        stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n        self.__interruptedAnimation = true;\n      }\n\n      // Stop animation\n      if (self.__isAnimating) {\n        stop(self.__isAnimating);\n        self.__isAnimating = false;\n        self.__interruptedAnimation = true;\n      }\n\n      // Use center point when dealing with two fingers\n      var currentTouchLeft, currentTouchTop;\n      var isSingleTouch = touches.length === 1;\n      if (isSingleTouch) {\n        currentTouchLeft = touches[0].pageX;\n        currentTouchTop = touches[0].pageY;\n      } else {\n        currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n        currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n      }\n\n      // Store initial positions\n      self.__initialTouchLeft = currentTouchLeft;\n      self.__initialTouchTop = currentTouchTop;\n\n      // Store current zoom level\n      self.__zoomLevelStart = self.__zoomLevel;\n\n      // Store initial touch positions\n      self.__lastTouchLeft = currentTouchLeft;\n      self.__lastTouchTop = currentTouchTop;\n\n      // Store initial move time stamp\n      self.__lastTouchMove = timeStamp;\n\n      // Reset initial scale\n      self.__lastScale = 1;\n\n      // Reset locking flags\n      self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n      self.__enableScrollY = !isSingleTouch && self.options.scrollingY;\n\n      // Reset tracking flag\n      self.__isTracking = true;\n\n      // Reset deceleration complete flag\n      self.__didDecelerationComplete = false;\n\n      // Dragging starts directly with two fingers, otherwise lazy with an offset\n      self.__isDragging = !isSingleTouch;\n\n      // Some features are disabled in multi touch scenarios\n      self.__isSingleTouch = isSingleTouch;\n\n      // Clearing data structure\n      self.__positions = [];\n    },\n\n    /**\n     * Touch move handler for scrolling support\n     * @public\n     */\n    doTouchMove: function (touches, timeStamp, scale) {\n      // Array-like check is enough here\n      if (touches.length == null) {\n        throw new Error(\"Invalid touch list: \" + touches);\n      }\n\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n      if (typeof timeStamp !== \"number\") {\n        throw new Error(\"Invalid timestamp value: \" + timeStamp);\n      }\n\n      var self = this;\n\n      // Ignore event when tracking is not enabled (event might be outside of element)\n      if (!self.__isTracking) {\n        return;\n      }\n\n      var currentTouchLeft, currentTouchTop;\n\n      // Compute move based around of center of fingers\n      if (touches.length === 2) {\n        currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n        currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n      } else {\n        currentTouchLeft = touches[0].pageX;\n        currentTouchTop = touches[0].pageY;\n      }\n\n      var positions = self.__positions;\n\n      // Are we already is dragging mode?\n      if (self.__isDragging) {\n        // Compute move distance\n        var moveX = currentTouchLeft - self.__lastTouchLeft;\n        var moveY = currentTouchTop - self.__lastTouchTop;\n\n        // Read previous scroll position and zooming\n        var scrollLeft = self.__scrollLeft;\n        var scrollTop = self.__scrollTop;\n        var level = self.__zoomLevel;\n\n        // Work with scaling\n        if (scale != null && self.options.zooming) {\n          var oldLevel = level;\n\n          // Recompute level based on previous scale and new scale\n          level = (level / self.__lastScale) * scale;\n\n          // Limit level according to configuration\n          level = Math.max(\n            Math.min(level, self.options.maxZoom),\n            self.options.minZoom\n          );\n\n          // Only do further compution when change happened\n          if (oldLevel !== level) {\n            // Compute relative event position to container\n            var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n            var currentTouchTopRel = currentTouchTop - self.__clientTop;\n\n            // Recompute left and top coordinates based on new zoom level\n            scrollLeft =\n              ((currentTouchLeftRel + scrollLeft) * level) / oldLevel -\n              currentTouchLeftRel;\n            scrollTop =\n              ((currentTouchTopRel + scrollTop) * level) / oldLevel -\n              currentTouchTopRel;\n\n            // Recompute max scroll values\n            self.__computeScrollMax(level);\n          }\n        }\n\n        if (self.__enableScrollX) {\n          scrollLeft -= moveX * this.options.speedMultiplier;\n          var maxScrollLeft = self.__maxScrollLeft;\n\n          if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n            // Slow down on the edges\n            if (self.options.bouncing) {\n              scrollLeft += (moveX / 2) * this.options.speedMultiplier;\n            } else if (scrollLeft > maxScrollLeft) {\n              scrollLeft = maxScrollLeft;\n            } else {\n              scrollLeft = 0;\n            }\n          }\n        }\n\n        // Compute new vertical scroll position\n        if (self.__enableScrollY) {\n          scrollTop -= moveY * this.options.speedMultiplier;\n          var maxScrollTop = self.__maxScrollTop;\n\n          if (scrollTop > maxScrollTop || scrollTop < 0) {\n            // Slow down on the edges\n            if (self.options.bouncing) {\n              scrollTop += (moveY / 2) * this.options.speedMultiplier;\n\n              // Support pull-to-refresh (only when only y is scrollable)\n              if (!self.__enableScrollX && self.__refreshHeight != null) {\n                if (\n                  !self.__refreshActive &&\n                  scrollTop <= -self.__refreshHeight\n                ) {\n                  self.__refreshActive = true;\n                  if (self.__refreshActivate) {\n                    self.__refreshActivate();\n                  }\n                } else if (\n                  self.__refreshActive &&\n                  scrollTop > -self.__refreshHeight\n                ) {\n                  self.__refreshActive = false;\n                  if (self.__refreshDeactivate) {\n                    self.__refreshDeactivate();\n                  }\n                }\n              }\n            } else if (scrollTop > maxScrollTop) {\n              scrollTop = maxScrollTop;\n            } else {\n              scrollTop = 0;\n            }\n          }\n        }\n\n        // Keep list from growing infinitely (holding min 10, max 20 measure points)\n        if (positions.length > 60) {\n          positions.splice(0, 30);\n        }\n\n        // Track scroll movement for decleration\n        positions.push(scrollLeft, scrollTop, timeStamp);\n\n        // Sync scroll position\n        self.__publish(scrollLeft, scrollTop, level);\n\n        // Otherwise figure out whether we are switching into dragging mode now.\n      } else {\n        var minimumTrackingForScroll = self.options.locking ? 3 : 0;\n        var minimumTrackingForDrag = 5;\n\n        var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n        var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n\n        self.__enableScrollX =\n          self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n        self.__enableScrollY =\n          self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n\n        positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n\n        self.__isDragging =\n          (self.__enableScrollX || self.__enableScrollY) &&\n          (distanceX >= minimumTrackingForDrag ||\n            distanceY >= minimumTrackingForDrag);\n        if (self.__isDragging) {\n          self.__interruptedAnimation = false;\n        }\n      }\n\n      // Update last touch positions and time stamp for next event\n      self.__lastTouchLeft = currentTouchLeft;\n      self.__lastTouchTop = currentTouchTop;\n      self.__lastTouchMove = timeStamp;\n      self.__lastScale = scale;\n    },\n\n    /**\n     * Touch end handler for scrolling support\n     * @public\n     */\n    doTouchEnd: function (timeStamp) {\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n      if (typeof timeStamp !== \"number\") {\n        throw new Error(\"Invalid timestamp value: \" + timeStamp);\n      }\n\n      var self = this;\n\n      // Ignore event when tracking is not enabled (no touchstart event on element)\n      // This is required as this listener ('touchmove') sits on the document and not on the element itself.\n      if (!self.__isTracking) {\n        return;\n      }\n\n      // Not touching anymore (when two finger hit the screen there are two touch end events)\n      self.__isTracking = false;\n\n      // Be sure to reset the dragging flag now. Here we also detect whether\n      // the finger has moved fast enough to switch into a deceleration animation.\n      if (self.__isDragging) {\n        // Reset dragging flag\n        self.__isDragging = false;\n\n        // Start deceleration\n        // Verify that the last move detected was in some relevant time frame\n        if (\n          self.__isSingleTouch &&\n          self.options.animating &&\n          timeStamp - self.__lastTouchMove <= 100\n        ) {\n          // Then figure out what the scroll position was about 100ms ago\n          var positions = self.__positions;\n          var endPos = positions.length - 1;\n          var startPos = endPos;\n\n          // Move pointer to position measured 100ms ago\n          for (\n            var i = endPos;\n            i > 0 && positions[i] > self.__lastTouchMove - 100;\n            i -= 3\n          ) {\n            startPos = i;\n          }\n\n          // If start and stop position is identical in a 100ms timeframe,\n          // we cannot compute any useful deceleration.\n          if (startPos !== endPos) {\n            // Compute relative movement between these two points\n            var timeOffset = positions[endPos] - positions[startPos];\n            var movedLeft = self.__scrollLeft - positions[startPos - 2];\n            var movedTop = self.__scrollTop - positions[startPos - 1];\n\n            // Based on 50ms compute the movement to apply for each render step\n            self.__decelerationVelocityX =\n              (movedLeft / timeOffset) * (1000 / 60);\n            self.__decelerationVelocityY =\n              (movedTop / timeOffset) * (1000 / 60);\n\n            // How much velocity is required to start the deceleration\n            var minVelocityToStartDeceleration =\n              self.options.paging || self.options.snapping ? 4 : 1;\n\n            // Verify that we have enough velocity to start deceleration\n            if (\n              Math.abs(self.__decelerationVelocityX) >\n                minVelocityToStartDeceleration ||\n              Math.abs(self.__decelerationVelocityY) >\n                minVelocityToStartDeceleration\n            ) {\n              // Deactivate pull-to-refresh when decelerating\n              if (!self.__refreshActive) {\n                self.__startDeceleration(timeStamp);\n              }\n            } else {\n              self.options.scrollingComplete();\n            }\n          } else {\n            self.options.scrollingComplete();\n          }\n        } else if (timeStamp - self.__lastTouchMove > 100) {\n          self.options.scrollingComplete();\n        }\n      }\n\n      // If this was a slower move it is per default non decelerated, but this\n      // still means that we want snap back to the bounds which is done here.\n      // This is placed outside the condition above to improve edge case stability\n      // e.g. touchend fired without enabled dragging. This should normally do not\n      // have modified the scroll positions or even showed the scrollbars though.\n      if (!self.__isDecelerating) {\n        if (self.__refreshActive && self.__refreshStart) {\n          // Use publish instead of scrollTo to allow scrolling to out of boundary position\n          // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n          self.__publish(\n            self.__scrollLeft,\n            -self.__refreshHeight,\n            self.__zoomLevel,\n            true\n          );\n\n          if (self.__refreshStart) {\n            self.__refreshStart();\n          }\n        } else {\n          if (self.__interruptedAnimation || self.__isDragging) {\n            self.options.scrollingComplete();\n          }\n          self.scrollTo(\n            self.__scrollLeft,\n            self.__scrollTop,\n            true,\n            self.__zoomLevel\n          );\n\n          // Directly signalize deactivation (nothing todo on refresh?)\n          if (self.__refreshActive) {\n            self.__refreshActive = false;\n            if (self.__refreshDeactivate) {\n              self.__refreshDeactivate();\n            }\n          }\n        }\n      }\n\n      // Fully cleanup list\n      self.__positions.length = 0;\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      PRIVATE API\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Applies the scroll position to the content element\n     *\n     * @private\n     *\n     * @param left {Number} Left scroll position\n     * @param top {Number} Top scroll position\n     * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\n     */\n    __publish: function (left, top, zoom, animate) {\n      var self = this;\n\n      // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n      var wasAnimating = self.__isAnimating;\n      if (wasAnimating) {\n        stop(wasAnimating);\n        self.__isAnimating = false;\n      }\n\n      if (animate && self.options.animating) {\n        // Keep scheduled positions for scrollBy/zoomBy functionality\n        self.__scheduledLeft = left;\n        self.__scheduledTop = top;\n        self.__scheduledZoom = zoom;\n\n        var oldLeft = self.__scrollLeft;\n        var oldTop = self.__scrollTop;\n        var oldZoom = self.__zoomLevel;\n\n        var diffLeft = left - oldLeft;\n        var diffTop = top - oldTop;\n        var diffZoom = zoom - oldZoom;\n\n        var step = function (percent, now, render) {\n          if (render) {\n            self.__scrollLeft = oldLeft + diffLeft * percent;\n            self.__scrollTop = oldTop + diffTop * percent;\n            self.__zoomLevel = oldZoom + diffZoom * percent;\n\n            // Push values out\n            if (self.__callback) {\n              self.__callback(\n                self.__scrollLeft,\n                self.__scrollTop,\n                self.__zoomLevel\n              );\n            }\n          }\n        };\n\n        var verify = function (id) {\n          return self.__isAnimating === id;\n        };\n\n        var completed = function (\n          renderedFramesPerSecond,\n          animationId,\n          wasFinished\n        ) {\n          if (animationId === self.__isAnimating) {\n            self.__isAnimating = false;\n          }\n          if (self.__didDecelerationComplete || wasFinished) {\n            self.options.scrollingComplete();\n          }\n\n          if (self.options.zooming) {\n            self.__computeScrollMax();\n            if (self.__zoomComplete) {\n              self.__zoomComplete();\n              self.__zoomComplete = null;\n            }\n          }\n        };\n\n        // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n        self.__isAnimating = start(\n          step,\n          verify,\n          completed,\n          self.options.animationDuration,\n          wasAnimating ? easeOutCubic : easeInOutCubic\n        );\n      } else {\n        self.__scheduledLeft = self.__scrollLeft = left;\n        self.__scheduledTop = self.__scrollTop = top;\n        self.__scheduledZoom = self.__zoomLevel = zoom;\n\n        // Push values out\n        if (self.__callback) {\n          self.__callback(left, top, zoom);\n        }\n\n        // Fix max scroll ranges\n        if (self.options.zooming) {\n          self.__computeScrollMax();\n          if (self.__zoomComplete) {\n            self.__zoomComplete();\n            self.__zoomComplete = null;\n          }\n        }\n      }\n    },\n\n    /**\n     * Recomputes scroll minimum values based on client dimensions and content dimensions.\n     * @private\n     */\n    __computeScrollMax: function (zoomLevel) {\n      var self = this;\n\n      if (zoomLevel == null) {\n        zoomLevel = self.__zoomLevel;\n      }\n\n      self.__maxScrollLeft = Math.max(\n        self.__contentWidth * zoomLevel - self.__clientWidth,\n        0\n      );\n      self.__maxScrollTop = Math.max(\n        self.__contentHeight * zoomLevel - self.__clientHeight,\n        0\n      );\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      ANIMATION (DECELERATION) SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Called when a touch sequence end and the speed of the finger was high enough\n     * to switch into deceleration mode.\n     * @private\n     */\n    __startDeceleration: function (timeStamp) {\n      var self = this;\n\n      if (self.options.paging) {\n        var scrollLeft = Math.max(\n          Math.min(self.__scrollLeft, self.__maxScrollLeft),\n          0\n        );\n        var scrollTop = Math.max(\n          Math.min(self.__scrollTop, self.__maxScrollTop),\n          0\n        );\n        var clientWidth = self.__clientWidth;\n        var clientHeight = self.__clientHeight;\n\n        // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n        // Each page should have exactly the size of the client area.\n        self.__minDecelerationScrollLeft =\n          Math.floor(scrollLeft / clientWidth) * clientWidth;\n        self.__minDecelerationScrollTop =\n          Math.floor(scrollTop / clientHeight) * clientHeight;\n        self.__maxDecelerationScrollLeft =\n          Math.ceil(scrollLeft / clientWidth) * clientWidth;\n        self.__maxDecelerationScrollTop =\n          Math.ceil(scrollTop / clientHeight) * clientHeight;\n      } else {\n        self.__minDecelerationScrollLeft = 0;\n        self.__minDecelerationScrollTop = 0;\n        self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n        self.__maxDecelerationScrollTop = self.__maxScrollTop;\n      }\n\n      // Wrap class method\n      var step = function (percent, now, render) {\n        self.__stepThroughDeceleration(render);\n      };\n\n      // How much velocity is required to keep the deceleration running\n      var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\n\n      // Detect whether it's still worth to continue animating steps\n      // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n      var verify = function () {\n        var shouldContinue =\n          Math.abs(self.__decelerationVelocityX) >=\n            minVelocityToKeepDecelerating ||\n          Math.abs(self.__decelerationVelocityY) >=\n            minVelocityToKeepDecelerating;\n        if (!shouldContinue) {\n          self.__didDecelerationComplete = true;\n        }\n        return shouldContinue;\n      };\n\n      var completed = function (\n        renderedFramesPerSecond,\n        animationId,\n        wasFinished\n      ) {\n        self.__isDecelerating = false;\n        if (self.__didDecelerationComplete) {\n          self.options.scrollingComplete();\n        }\n\n        // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n        self.scrollTo(\n          self.__scrollLeft,\n          self.__scrollTop,\n          self.options.snapping\n        );\n      };\n\n      // Start animation and switch on flag\n      self.__isDecelerating = start(step, verify, completed);\n    },\n\n    /**\n     * Called on every step of the animation\n     *\n     * @param {Function} [render] Whether to not render the current step, but keep it in memory only. Used internally only!\n     * @private\n     */\n    __stepThroughDeceleration: function (render) {\n      var self = this;\n\n      //\n      // COMPUTE NEXT SCROLL POSITION\n      //\n\n      // Add deceleration to scroll position\n      var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n      var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\n      //\n      // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n      //\n\n      if (!self.options.bouncing) {\n        var scrollLeftFixed = Math.max(\n          Math.min(self.__maxDecelerationScrollLeft, scrollLeft),\n          self.__minDecelerationScrollLeft\n        );\n        if (scrollLeftFixed !== scrollLeft) {\n          scrollLeft = scrollLeftFixed;\n          self.__decelerationVelocityX = 0;\n        }\n\n        var scrollTopFixed = Math.max(\n          Math.min(self.__maxDecelerationScrollTop, scrollTop),\n          self.__minDecelerationScrollTop\n        );\n        if (scrollTopFixed !== scrollTop) {\n          scrollTop = scrollTopFixed;\n          self.__decelerationVelocityY = 0;\n        }\n      }\n\n      //\n      // UPDATE SCROLL POSITION\n      //\n\n      if (render) {\n        self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n      } else {\n        self.__scrollLeft = scrollLeft;\n        self.__scrollTop = scrollTop;\n      }\n\n      //\n      // SLOW DOWN\n      //\n\n      // Slow down velocity on every iteration\n      if (!self.options.paging) {\n        // This is the factor applied to every iteration of the animation\n        // to slow down the process. This should emulate natural behavior where\n        // objects slow down when the initiator of the movement is removed\n        var frictionFactor = 0.95;\n\n        self.__decelerationVelocityX *= frictionFactor;\n        self.__decelerationVelocityY *= frictionFactor;\n      }\n\n      //\n      // BOUNCING SUPPORT\n      //\n\n      if (self.options.bouncing) {\n        var scrollOutsideX = 0;\n        var scrollOutsideY = 0;\n\n        // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n        var penetrationDeceleration = self.options.penetrationDeceleration;\n        var penetrationAcceleration = self.options.penetrationAcceleration;\n\n        // Check limits\n        if (scrollLeft < self.__minDecelerationScrollLeft) {\n          scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n        } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n          scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n        }\n\n        if (scrollTop < self.__minDecelerationScrollTop) {\n          scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n        } else if (scrollTop > self.__maxDecelerationScrollTop) {\n          scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n        }\n\n        // Slow down until slow enough, then flip back to snap position\n        if (scrollOutsideX !== 0) {\n          if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n            self.__decelerationVelocityX +=\n              scrollOutsideX * penetrationDeceleration;\n          } else {\n            self.__decelerationVelocityX =\n              scrollOutsideX * penetrationAcceleration;\n          }\n        }\n\n        if (scrollOutsideY !== 0) {\n          if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n            self.__decelerationVelocityY +=\n              scrollOutsideY * penetrationDeceleration;\n          } else {\n            self.__decelerationVelocityY =\n              scrollOutsideY * penetrationAcceleration;\n          }\n        }\n      }\n    },\n  };\n\n  // Copy over members to prototype\n  for (var key in members) {\n    Scroller.prototype[key] = members[key];\n  }\n})();\n\nexport default Scroller;\n"],"names":["global","window","running","counter","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","stop","id","cleared","start","stepCallback","verifyCallback","completedCallback","duration","easingMethod","Date","now","lastFrame","percent","dropCounter","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","value","Scroller","easeOutCubic","pos","pow","easeInOutCubic","defaults","scrollingX","scrollingY","animating","animationDuration","bouncing","locking","paging","snapping","zooming","minZoom","maxZoom","speedMultiplier","scrollingComplete","penetrationDeceleration","penetrationAcceleration","callback","options","this","__callback","Object","assign","members","i","h","s","o","l","u","_","v","M","m","p","g","T","D","S","L","Z","I","A","H","P","R","V","W","k","B","C","X","Y","G","O","q","F","J","K","N","U","setDimensions","clientWidth","clientHeight","contentWidth","contentHeight","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__computeScrollMax","scrollTo","__scrollLeft","__scrollTop","setPosition","left","top","__clientLeft","__clientTop","setSnapSize","width","height","__snapWidth","__snapHeight","activatePullToRefresh","activateCallback","deactivateCallback","startCallback","__refreshHeight","__refreshActivate","__refreshDeactivate","__refreshStart","triggerPullToRefresh","__publish","__zoomLevel","finishPullToRefresh","__refreshActive","getValues","zoom","getScrollMax","__maxScrollLeft","__maxScrollTop","zoomTo","level","animate","originLeft","originTop","Error","__zoomComplete","__isDecelerating","oldLevel","max","zoomBy","factor","__isTracking","scrollBy","startLeft","__isAnimating","__scheduledLeft","startTop","__scheduledTop","doMouseZoom","wheelDelta","timeStamp","pageX","pageY","change","doTouchStart","touches","length","valueOf","currentTouchLeft","currentTouchTop","__interruptedAnimation","isSingleTouch","abs","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__lastScale","__enableScrollX","__enableScrollY","__didDecelerationComplete","__isDragging","__isSingleTouch","__positions","doTouchMove","scale","positions","moveX","moveY","scrollLeft","scrollTop","currentTouchLeftRel","currentTouchTopRel","maxScrollLeft","maxScrollTop","splice","push","minimumTrackingForScroll","distanceX","distanceY","doTouchEnd","endPos","startPos","timeOffset","movedLeft","movedTop","__decelerationVelocityX","__decelerationVelocityY","minVelocityToStartDeceleration","__startDeceleration","tt","self","wasAnimating","__scheduledZoom","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","renderedFramesPerSecond","animationId","wasFinished","$","zoomLevel","rt","__minDecelerationScrollLeft","floor","__minDecelerationScrollTop","__maxDecelerationScrollLeft","ceil","__maxDecelerationScrollTop","minVelocityToKeepDecelerating","__stepThroughDeceleration","shouldContinue","ut","scrollLeftFixed","scrollTopFixed","scrollOutsideX","scrollOutsideY","key","prototype"],"mappings":"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"}
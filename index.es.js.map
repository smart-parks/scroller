{"version":3,"file":"index.es.js","sources":["src/Animate.js","src/easing.js","src/Scroller.js"],"sourcesContent":["/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\n/**\n * Generic animation class with support for dropped frames both optional easing and duration.\n *\n * Optional duration is useful when the lifetime is defined by another condition than time\n * e.g. speed of an animating object, etc.\n *\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n * based on the pure time difference.\n */\n\nconst global = typeof window == \"undefined\" ? {} : window;\n\nconst desiredFrames = 60;\nconst millisecondsPerSecond = 1000;\n\nlet running = {};\nlet counter = 1;\n\n/**\n * A requestAnimationFrame wrapper / polyfill.\n *\n * @param callback {Function} The callback to be invoked before the next repaint.\n */\nconst requestAnimationFrame =\n  global.requestAnimationFrame ||\n  global.webkitRequestAnimationFrame ||\n  global.mozRequestAnimationFrame ||\n  global.oRequestAnimationFrame;\n\n/**\n * Stops the given animation.\n *\n * @param {number} id Unique animation ID\n * @return {boolean} Whether the animation was stopped (aka, was running before)\n */\nexport function stop(id) {\n  var cleared = running[id] != null;\n\n  if (cleared) {\n    running[id] = null;\n  }\n\n  return cleared;\n}\n\n/**\n * Whether the given animation is still running.\n *\n * @param {number} id Unique animation ID\n * @return {boolean} Whether the animation is still running\n */\nexport function isRunning(id) {\n  return running[id] != null;\n}\n\n/**\n * Start the animation.\n *\n * @param {Function} stepCallback Pointer to function which is executed on every step. Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n * @param {Function} verifyCallback Executed before every animation step. Signature of the method should be `function() { return continueWithAnimation; }`\n * @param {Function} completedCallback Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n * @param {number} [duration] Milliseconds to run the animation\n * @param {Function} [easingMethod] Pointer to easing function Signature of the method should be `function(percent) { return modifiedValue; }` usage of requestAnimationFrame.\n * @return {number} Identifier of animation. Can be used to stop it any time.\n */\nexport function start(\n  stepCallback,\n  verifyCallback,\n  completedCallback,\n  duration,\n  easingMethod\n) {\n  var start = Date.now();\n  var lastFrame = start;\n  var percent = 0;\n  var dropCounter = 0;\n  var id = counter++;\n\n  // Compacting running db automatically every few new animations\n  if (id % 20 === 0) {\n    var newRunning = {};\n    for (var usedId in running) {\n      newRunning[usedId] = true;\n    }\n    running = newRunning;\n  }\n\n  // This is the internal step method which is called every few milliseconds\n  var step = function (virtual) {\n    // Normalize virtual value\n    var render = virtual !== true;\n\n    // Get current time\n    var now = Date.now();\n\n    // Verification is executed before next animation step\n    if (!running[id] || (verifyCallback && !verifyCallback(id))) {\n      running[id] = null;\n      completedCallback &&\n        completedCallback(\n          desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond),\n          id,\n          false\n        );\n      return;\n    }\n\n    // For the current rendering to apply let's update omitted steps in memory.\n    // This is important to bring internal state variables up-to-date with progress in time.\n    if (render) {\n      var droppedFrames =\n        Math.round(\n          (now - lastFrame) / (millisecondsPerSecond / desiredFrames)\n        ) - 1;\n      for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n        step(true);\n        dropCounter++;\n      }\n    }\n\n    // Compute percent value\n    if (duration) {\n      percent = (now - start) / duration;\n      if (percent > 1) {\n        percent = 1;\n      }\n    }\n\n    // Execute step callback, then...\n    var value = easingMethod ? easingMethod(percent) : percent;\n    if (\n      (stepCallback(value, now, render) === false || percent === 1) &&\n      render\n    ) {\n      running[id] = null;\n      completedCallback &&\n        completedCallback(\n          desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond),\n          id,\n          percent === 1 || duration == null\n        );\n    } else if (render) {\n      lastFrame = now;\n      requestAnimationFrame(step);\n    }\n  };\n\n  // Mark as running\n  running[id] = true;\n\n  // Init first step\n  requestAnimationFrame(step);\n\n  // Return unique animation ID\n  return id;\n}\n","// Easing Equations (c) 2003 Robert Penner, all rights reserved.\n// Open source under the BSD License.\n\n/**\n * @private\n * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n **/\nexport function easeOutCubic(pos) {\n  return Math.pow(pos - 1, 3) + 1;\n}\n\n/**\n * @private\n * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n **/\nexport function easeInOutCubic(pos) {\n  if ((pos /= 0.5) < 1) {\n    return 0.5 * Math.pow(pos, 3);\n  }\n\n  return 0.5 * (Math.pow(pos - 2, 3) + 2);\n}\n","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\nimport { start, stop } from \"./Animate.js\";\nimport { easeOutCubic, easeInOutCubic } from \"./easing.js\";\n\nfunction NOOP() {}\n\n/**\n * @public\n */\nconst defaults = {\n  /** Enable scrolling on x-axis */\n  scrollingX: true,\n\n  /** Enable scrolling on y-axis */\n  scrollingY: true,\n\n  /** Enable animations for deceleration, snap back, zooming and scrolling */\n  animating: true,\n\n  /** duration for animations triggered by scrollTo/zoomTo */\n  animationDuration: 250,\n\n  /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n  bouncing: true,\n\n  /** Enable locking to the main axis if user moves only slightly on one of them at start */\n  locking: true,\n\n  /** Enable pagination mode (switching between full page content panes) */\n  paging: false,\n\n  /** Enable snapping of content to a configured pixel grid */\n  snapping: false,\n\n  /** Enable zooming of content via API, fingers and mouse wheel */\n  zooming: false,\n\n  /** Minimum zoom level */\n  minZoom: 0.5,\n\n  /** Maximum zoom level */\n  maxZoom: 3,\n\n  /** Multiply or decrease scrolling speed **/\n  speedMultiplier: 1,\n\n  /** Callback that is fired on the later of touch end or deceleration end,\n         provided that another scrolling action has not begun. Used to know\n         when to fade out a scrollbar. */\n  scrollingComplete: NOOP,\n\n  /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n  penetrationDeceleration: 0.03,\n\n  /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n  penetrationAcceleration: 0.08,\n};\n\n/**\n * A pure logic 'component' for 'virtual' scrolling/zooming.\n * @constructor\n * @public\n */\nfunction Scroller(callback, options) {\n  this.__callback = callback;\n\n  this.options = Object.assign({}, defaults, options);\n}\n\n// Easing Equations (c) 2003 Robert Penner, all rights reserved.\n// Open source under the BSD License.\n\nScroller.prototype = {\n  /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: STATUS\n    ---------------------------------------------------------------------------\n    */\n\n  /** {Boolean} Whether only a single finger is used in touch handling */\n  __isSingleTouch: false,\n\n  /** {Boolean} Whether a touch event sequence is in progress */\n  __isTracking: false,\n\n  /** {Boolean} Whether a deceleration animation went to completion. */\n  __didDecelerationComplete: false,\n\n  /**\n   * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\n   * a gesturestart event happens. This has higher priority than dragging.\n   */\n  __isGesturing: false,\n\n  /**\n   * {Boolean} Whether the user has moved by such a distance that we have enabled\n   * dragging mode. Hint: It's only enabled after some pixels of movement to\n   * not interrupt with clicks etc.\n   */\n  __isDragging: false,\n\n  /**\n   * {Boolean} Not touching and dragging anymore, and smoothly animating the\n   * touch sequence using deceleration.\n   */\n  __isDecelerating: false,\n\n  /**\n   * {Boolean} Smoothly animating the currently configured change\n   */\n  __isAnimating: false,\n\n  /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: DIMENSIONS\n    ---------------------------------------------------------------------------\n    */\n\n  /** {Integer} Available outer left position (from document perspective) */\n  __clientLeft: 0,\n\n  /** {Integer} Available outer top position (from document perspective) */\n  __clientTop: 0,\n\n  /** {Integer} Available outer width */\n  __clientWidth: 0,\n\n  /** {Integer} Available outer height */\n  __clientHeight: 0,\n\n  /** {Integer} Outer width of content */\n  __contentWidth: 0,\n\n  /** {Integer} Outer height of content */\n  __contentHeight: 0,\n\n  /** {Integer} Snapping width for content */\n  __snapWidth: 100,\n\n  /** {Integer} Snapping height for content */\n  __snapHeight: 100,\n\n  /** {Integer} Height to assign to refresh area */\n  __refreshHeight: null,\n\n  /** {Boolean} Whether the refresh process is enabled when the event is released now */\n  __refreshActive: false,\n\n  /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n  __refreshActivate: null,\n\n  /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n  __refreshDeactivate: null,\n\n  /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n  __refreshStart: null,\n\n  /** {Number} Zoom level */\n  __zoomLevel: 1,\n\n  /** {Number} Scroll position on x-axis */\n  __scrollLeft: 0,\n\n  /** {Number} Scroll position on y-axis */\n  __scrollTop: 0,\n\n  /** {Integer} Maximum allowed scroll position on x-axis */\n  __maxScrollLeft: 0,\n\n  /** {Integer} Maximum allowed scroll position on y-axis */\n  __maxScrollTop: 0,\n\n  /* {Number} Scheduled left position (final position when animating) */\n  __scheduledLeft: 0,\n\n  /* {Number} Scheduled top position (final position when animating) */\n  __scheduledTop: 0,\n\n  /* {Number} Scheduled zoom level (final scale when animating) */\n  __scheduledZoom: 0,\n\n  /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: LAST POSITIONS\n    ---------------------------------------------------------------------------\n    */\n\n  /** {Number} Left position of finger at start */\n  __lastTouchLeft: null,\n\n  /** {Number} Top position of finger at start */\n  __lastTouchTop: null,\n\n  /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n  __lastTouchMove: null,\n\n  /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n  __positions: null,\n\n  /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: DECELERATION SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n  /** {Integer} Minimum left scroll position during deceleration */\n  __minDecelerationScrollLeft: null,\n\n  /** {Integer} Minimum top scroll position during deceleration */\n  __minDecelerationScrollTop: null,\n\n  /** {Integer} Maximum left scroll position during deceleration */\n  __maxDecelerationScrollLeft: null,\n\n  /** {Integer} Maximum top scroll position during deceleration */\n  __maxDecelerationScrollTop: null,\n\n  /** {Number} Current factor to modify horizontal scroll position with on every step */\n  __decelerationVelocityX: null,\n\n  /** {Number} Current factor to modify vertical scroll position with on every step */\n  __decelerationVelocityY: null,\n\n  /*\n    ---------------------------------------------------------------------------\n      PUBLIC API\n    ---------------------------------------------------------------------------\n    */\n\n  /**\n   * Configures the dimensions of the client (outer) and content (inner) elements.\n   * Requires the available space for the outer element and the outer size of the inner element.\n   * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n   *\n   * @public\n   *\n   * @param clientWidth {Integer ? null} Inner width of outer element\n   * @param clientHeight {Integer ? null} Inner height of outer element\n   * @param contentWidth {Integer ? null} Outer width of inner element\n   * @param contentHeight {Integer ? null} Outer height of inner element\n   */\n  setDimensions: function (\n    clientWidth,\n    clientHeight,\n    contentWidth,\n    contentHeight\n  ) {\n    var self = this;\n\n    // Only update values which are defined\n    if (clientWidth === +clientWidth) {\n      self.__clientWidth = clientWidth;\n    }\n\n    if (clientHeight === +clientHeight) {\n      self.__clientHeight = clientHeight;\n    }\n\n    if (contentWidth === +contentWidth) {\n      self.__contentWidth = contentWidth;\n    }\n\n    if (contentHeight === +contentHeight) {\n      self.__contentHeight = contentHeight;\n    }\n\n    // Refresh maximums\n    self.__computeScrollMax();\n\n    // Refresh scroll position\n    self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n  },\n\n  /**\n   * Sets the client coordinates in relation to the document.\n   *\n   * @public\n   *\n   * @param left {Integer ? 0} Left position of outer element\n   * @param top {Integer ? 0} Top position of outer element\n   */\n  setPosition: function (left, top) {\n    var self = this;\n\n    self.__clientLeft = left || 0;\n    self.__clientTop = top || 0;\n  },\n\n  /**\n   * Configures the snapping (when snapping is active)\n   *\n   * @public\n   *\n   * @param width {Integer} Snapping width\n   * @param height {Integer} Snapping height\n   */\n  setSnapSize: function (width, height) {\n    var self = this;\n\n    self.__snapWidth = width;\n    self.__snapHeight = height;\n  },\n\n  /**\n   * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n   * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n   * the official Twitter client.\n   *\n   * @public\n   *\n   * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n   * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n   * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n   * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n   */\n  activatePullToRefresh: function (\n    height,\n    activateCallback,\n    deactivateCallback,\n    startCallback\n  ) {\n    var self = this;\n\n    self.__refreshHeight = height;\n    self.__refreshActivate = activateCallback;\n    self.__refreshDeactivate = deactivateCallback;\n    self.__refreshStart = startCallback;\n  },\n\n  /**\n   * Starts pull-to-refresh manually.\n   * @public\n   */\n  triggerPullToRefresh: function () {\n    // Use publish instead of scrollTo to allow scrolling to out of boundary position\n    // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n    this.__publish(\n      this.__scrollLeft,\n      -this.__refreshHeight,\n      this.__zoomLevel,\n      true\n    );\n\n    if (this.__refreshStart) {\n      this.__refreshStart();\n    }\n  },\n\n  /**\n   * Signalizes that pull-to-refresh is finished.\n   * @public\n   */\n  finishPullToRefresh: function () {\n    var self = this;\n\n    self.__refreshActive = false;\n    if (self.__refreshDeactivate) {\n      self.__refreshDeactivate();\n    }\n\n    self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n  },\n\n  /**\n   * Returns the scroll position and zooming values\n   *\n   * @public\n   *\n   * @return {Object} `left` and `top` scroll position and `zoom` level\n   */\n  getValues: function () {\n    var self = this;\n\n    return {\n      left: self.__scrollLeft,\n      top: self.__scrollTop,\n      zoom: self.__zoomLevel,\n    };\n  },\n\n  /**\n   * Returns the maximum scroll values\n   *\n   * @public\n   *\n   * @return {Object} `left` and `top` maximum scroll values\n   */\n  getScrollMax: function () {\n    var self = this;\n\n    return {\n      left: self.__maxScrollLeft,\n      top: self.__maxScrollTop,\n    };\n  },\n\n  /**\n   * Zooms to the given level. Supports optional animation. Zooms\n   * the center when no coordinates are given.\n   *\n   * @public\n   *\n   * @param level {Number} Level to zoom to\n   * @param animate {Boolean ? false} Whether to use animation\n   * @param originLeft {Number ? null} Zoom in at given left coordinate\n   * @param originTop {Number ? null} Zoom in at given top coordinate\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n   */\n  zoomTo: function (level, animate, originLeft, originTop, callback) {\n    var self = this;\n\n    if (!self.options.zooming) {\n      throw new Error(\"Zooming is not enabled!\");\n    }\n\n    // Add callback if exists\n    if (callback) {\n      self.__zoomComplete = callback;\n    }\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    var oldLevel = self.__zoomLevel;\n\n    // Normalize input origin to center of viewport if not defined\n    if (originLeft == null) {\n      originLeft = self.__clientWidth / 2;\n    }\n\n    if (originTop == null) {\n      originTop = self.__clientHeight / 2;\n    }\n\n    // Limit level according to configuration\n    level = Math.max(\n      Math.min(level, self.options.maxZoom),\n      self.options.minZoom\n    );\n\n    // Recompute maximum values while temporary tweaking maximum scroll ranges\n    self.__computeScrollMax(level);\n\n    // Recompute left and top coordinates based on new zoom level\n    var left =\n      ((originLeft + self.__scrollLeft) * level) / oldLevel - originLeft;\n    var top = ((originTop + self.__scrollTop) * level) / oldLevel - originTop;\n\n    // Limit x-axis\n    if (left > self.__maxScrollLeft) {\n      left = self.__maxScrollLeft;\n    } else if (left < 0) {\n      left = 0;\n    }\n\n    // Limit y-axis\n    if (top > self.__maxScrollTop) {\n      top = self.__maxScrollTop;\n    } else if (top < 0) {\n      top = 0;\n    }\n\n    // Push values out\n    self.__publish(left, top, level, animate);\n  },\n\n  /**\n   * Zooms the content by the given factor.\n   *\n   * @public\n   *\n   * @param factor {Number} Zoom by given factor\n   * @param animate {Boolean ? false} Whether to use animation\n   * @param originLeft {Number ? 0} Zoom in at given left coordinate\n   * @param originTop {Number ? 0} Zoom in at given top coordinate\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n   */\n  zoomBy: function (factor, animate, originLeft, originTop, callback) {\n    var self = this;\n\n    self.zoomTo(\n      self.__zoomLevel * factor,\n      animate,\n      originLeft,\n      originTop,\n      callback\n    );\n  },\n\n  /**\n   * Scrolls to the given position. Respect limitations and snapping automatically.\n   *\n   * @public\n   *\n   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n   * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n   * @param zoom {Number?null} Zoom level to go to\n   */\n  scrollTo: function (left, top, animate, zoom) {\n    var self = this;\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    // Correct coordinates based on new zoom level\n    if (zoom != null && zoom !== self.__zoomLevel) {\n      if (!self.options.zooming) {\n        throw new Error(\"Zooming is not enabled!\");\n      }\n\n\n      left *= zoom;\n      top *= zoom;\n      // Recompute maximum values while temporary tweaking maximum scroll ranges\n      self.__computeScrollMax(zoom);\n    } else {\n      // Keep zoom when not defined\n      zoom = self.__zoomLevel;\n    }\n\n    if (!self.options.scrollingX) {\n      left = self.__scrollLeft;\n    } else {\n      if (self.options.paging) {\n        left = Math.round(left / self.__clientWidth) * self.__clientWidth;\n      } else if (self.options.snapping) {\n        left = Math.round(left / self.__snapWidth) * self.__snapWidth;\n      }\n    }\n\n    if (!self.options.scrollingY) {\n      top = self.__scrollTop;\n    } else {\n      if (self.options.paging) {\n        top = Math.round(top / self.__clientHeight) * self.__clientHeight;\n      } else if (self.options.snapping) {\n        top = Math.round(top / self.__snapHeight) * self.__snapHeight;\n      }\n    }\n\n    // Limit for allowed ranges\n    left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n    top = Math.max(Math.min(self.__maxScrollTop, top), 0);\n\n    // Don't animate when no change detected, still call publish to make sure\n    // that rendered position is really in-sync with internal data\n    if (left === self.__scrollLeft && top === self.__scrollTop) {\n      animate = false;\n    }\n\n    // Publish new values\n    if (!self.__isTracking) {\n      self.__publish(left, top, zoom, animate);\n    }\n  },\n\n  /**\n   * Scrolls to the given position, centering the position on the\n   *\n   * @public\n   *\n   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n   * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n   * @param zoom {Number?null} Zoom level to go to\n   */\n  scrollToViewportCenter(left, top, animate, zoom) {\n    zoom = zoom == null ? this.__zoomLevel : zoom\n\n    // TODO - it would be really awesome if we could animate this,\n    // however it appears to get in the way of panning.\n    this.zoomTo(zoom, false)\n\n    this.scrollTo(\n      left * zoom - this.__clientWidth * 0.5,\n      top * zoom - this.__clientHeight * 0.5,\n      animate\n    );\n  },\n\n  /**\n   * Scroll by the given offset\n   *\n   * @public\n   *\n   * @param left {Number ? 0} Scroll x-axis by given offset\n   * @param top {Number ? 0} Scroll x-axis by given offset\n   * @param animate {Boolean ? false} Whether to animate the given change\n   */\n  scrollBy: function (left, top, animate) {\n    var self = this;\n\n    var startLeft = self.__isAnimating\n      ? self.__scheduledLeft\n      : self.__scrollLeft;\n    var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n\n    self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n  },\n\n  /**\n   * Determine if a point is found within the bounds of a container\n   *\n   * @public\n   *\n   * @param x {Number} X coordinate of point\n   * @param y {Number} Y coordinate of point\n   *\n   * @returns {Boolean} True if found within container bounds\n   */\n  containsPoint(x, y) {\n    if (x < 0) {\n      return false;\n    }\n\n    if (x > self.__contentWidth) {\n      return false;\n    }\n\n    if (y < 0) {\n      return false;\n    }\n\n    if (y > self.__contentHeight) {\n      return false;\n    }\n\n    return true;\n  },\n\n  /*\n    ---------------------------------------------------------------------------\n      EVENT CALLBACKS\n    ---------------------------------------------------------------------------\n    */\n\n  /**\n   * Mouse wheel handler for zooming support\n   * @public\n   */\n  doMouseZoom: function (wheelDelta, timeStamp, pageX, pageY) {\n    var self = this;\n    var change = wheelDelta > 0 ? 0.97 : 1.03;\n\n    return self.zoomTo(\n      self.__zoomLevel * change,\n      false,\n      pageX - self.__clientLeft,\n      pageY - self.__clientTop\n    );\n  },\n\n  /**\n   * Touch start handler for scrolling support\n   * @public\n   */\n  doTouchStart: function (touches, timeStamp) {\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error(\"Invalid touch list: \" + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== \"number\") {\n      throw new Error(\"Invalid timestamp value: \" + timeStamp);\n    }\n\n    var self = this;\n\n    // Reset interruptedAnimation flag\n    self.__interruptedAnimation = true;\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Stop animation\n    if (self.__isAnimating) {\n      stop(self.__isAnimating);\n      self.__isAnimating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Use center point when dealing with two fingers\n    var currentTouchLeft, currentTouchTop;\n    var isSingleTouch = touches.length === 1;\n    if (isSingleTouch) {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    } else {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    }\n\n    // Store initial positions\n    self.__initialTouchLeft = currentTouchLeft;\n    self.__initialTouchTop = currentTouchTop;\n\n    // Store current zoom level\n    self.__zoomLevelStart = self.__zoomLevel;\n\n    // Store initial touch positions\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n\n    // Store initial move time stamp\n    self.__lastTouchMove = timeStamp;\n\n    // Reset initial scale\n    self.__lastScale = 1;\n\n    // Reset locking flags\n    self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n    self.__enableScrollY = !isSingleTouch && self.options.scrollingY;\n\n    // Reset tracking flag\n    self.__isTracking = true;\n\n    // Reset deceleration complete flag\n    self.__didDecelerationComplete = false;\n\n    // Dragging starts directly with two fingers, otherwise lazy with an offset\n    self.__isDragging = !isSingleTouch;\n\n    // Some features are disabled in multi touch scenarios\n    self.__isSingleTouch = isSingleTouch;\n\n    // Clearing data structure\n    self.__positions = [];\n  },\n\n  /**\n   * Touch move handler for scrolling support\n   * @public\n   */\n  doTouchMove: function (touches, timeStamp, scale) {\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error(\"Invalid touch list: \" + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== \"number\") {\n      throw new Error(\"Invalid timestamp value: \" + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (event might be outside of element)\n    if (!self.__isTracking) {\n      return;\n    }\n\n    var currentTouchLeft, currentTouchTop;\n\n    // Compute move based around of center of fingers\n    if (touches.length === 2) {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    } else {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    }\n\n    var positions = self.__positions;\n\n    // Are we already is dragging mode?\n    if (self.__isDragging) {\n      // Compute move distance\n      var moveX = currentTouchLeft - self.__lastTouchLeft;\n      var moveY = currentTouchTop - self.__lastTouchTop;\n\n      // Read previous scroll position and zooming\n      var scrollLeft = self.__scrollLeft;\n      var scrollTop = self.__scrollTop;\n      var level = self.__zoomLevel;\n\n      // Work with scaling\n      if (scale != null && self.options.zooming) {\n        var oldLevel = level;\n\n        // Recompute level based on previous scale and new scale\n        level = (level / self.__lastScale) * scale;\n\n        // Limit level according to configuration\n        level = Math.max(\n          Math.min(level, self.options.maxZoom),\n          self.options.minZoom\n        );\n\n        // Only do further compution when change happened\n        if (oldLevel !== level) {\n          // Compute relative event position to container\n          var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n          var currentTouchTopRel = currentTouchTop - self.__clientTop;\n\n          // Recompute left and top coordinates based on new zoom level\n          scrollLeft =\n            ((currentTouchLeftRel + scrollLeft) * level) / oldLevel -\n            currentTouchLeftRel;\n          scrollTop =\n            ((currentTouchTopRel + scrollTop) * level) / oldLevel -\n            currentTouchTopRel;\n\n          // Recompute max scroll values\n          self.__computeScrollMax(level);\n        }\n      }\n\n      if (self.__enableScrollX) {\n        scrollLeft -= moveX * this.options.speedMultiplier;\n        var maxScrollLeft = self.__maxScrollLeft;\n\n        if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n          // Slow down on the edges\n          if (self.options.bouncing) {\n            scrollLeft += (moveX / 2) * this.options.speedMultiplier;\n          } else if (scrollLeft > maxScrollLeft) {\n            scrollLeft = maxScrollLeft;\n          } else {\n            scrollLeft = 0;\n          }\n        }\n      }\n\n      // Compute new vertical scroll position\n      if (self.__enableScrollY) {\n        scrollTop -= moveY * this.options.speedMultiplier;\n        var maxScrollTop = self.__maxScrollTop;\n\n        if (scrollTop > maxScrollTop || scrollTop < 0) {\n          // Slow down on the edges\n          if (self.options.bouncing) {\n            scrollTop += (moveY / 2) * this.options.speedMultiplier;\n\n            // Support pull-to-refresh (only when only y is scrollable)\n            if (!self.__enableScrollX && self.__refreshHeight != null) {\n              if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n                self.__refreshActive = true;\n                if (self.__refreshActivate) {\n                  self.__refreshActivate();\n                }\n              } else if (\n                self.__refreshActive &&\n                scrollTop > -self.__refreshHeight\n              ) {\n                self.__refreshActive = false;\n                if (self.__refreshDeactivate) {\n                  self.__refreshDeactivate();\n                }\n              }\n            }\n          } else if (scrollTop > maxScrollTop) {\n            scrollTop = maxScrollTop;\n          } else {\n            scrollTop = 0;\n          }\n        }\n      }\n\n      // Keep list from growing infinitely (holding min 10, max 20 measure points)\n      if (positions.length > 60) {\n        positions.splice(0, 30);\n      }\n\n      // Track scroll movement for decleration\n      positions.push(scrollLeft, scrollTop, timeStamp);\n\n      // Sync scroll position\n      self.__publish(scrollLeft, scrollTop, level);\n\n      // Otherwise figure out whether we are switching into dragging mode now.\n    } else {\n      var minimumTrackingForScroll = self.options.locking ? 3 : 0;\n      var minimumTrackingForDrag = 5;\n\n      var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n      var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n\n      self.__enableScrollX =\n        self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n      self.__enableScrollY =\n        self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n\n      positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n\n      self.__isDragging =\n        (self.__enableScrollX || self.__enableScrollY) &&\n        (distanceX >= minimumTrackingForDrag ||\n          distanceY >= minimumTrackingForDrag);\n      if (self.__isDragging) {\n        self.__interruptedAnimation = false;\n      }\n    }\n\n    // Update last touch positions and time stamp for next event\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n    self.__lastTouchMove = timeStamp;\n    self.__lastScale = scale;\n  },\n\n  /**\n   * Touch end handler for scrolling support\n   * @public\n   */\n  doTouchEnd: function (timeStamp) {\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== \"number\") {\n      throw new Error(\"Invalid timestamp value: \" + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (no touchstart event on element)\n    // This is required as this listener ('touchmove') sits on the document and not on the element itself.\n    if (!self.__isTracking) {\n      return;\n    }\n\n    // Not touching anymore (when two finger hit the screen there are two touch end events)\n    self.__isTracking = false;\n\n    // Be sure to reset the dragging flag now. Here we also detect whether\n    // the finger has moved fast enough to switch into a deceleration animation.\n    if (self.__isDragging) {\n      // Reset dragging flag\n      self.__isDragging = false;\n\n      // Start deceleration\n      // Verify that the last move detected was in some relevant time frame\n      if (\n        self.__isSingleTouch &&\n        self.options.animating &&\n        timeStamp - self.__lastTouchMove <= 100\n      ) {\n        // Then figure out what the scroll position was about 100ms ago\n        var positions = self.__positions;\n        var endPos = positions.length - 1;\n        var startPos = endPos;\n\n        // Move pointer to position measured 100ms ago\n        for (\n          var i = endPos;\n          i > 0 && positions[i] > self.__lastTouchMove - 100;\n          i -= 3\n        ) {\n          startPos = i;\n        }\n\n        // If start and stop position is identical in a 100ms timeframe,\n        // we cannot compute any useful deceleration.\n        if (startPos !== endPos) {\n          // Compute relative movement between these two points\n          var timeOffset = positions[endPos] - positions[startPos];\n          var movedLeft = self.__scrollLeft - positions[startPos - 2];\n          var movedTop = self.__scrollTop - positions[startPos - 1];\n\n          // Based on 50ms compute the movement to apply for each render step\n          self.__decelerationVelocityX = (movedLeft / timeOffset) * (1000 / 60);\n          self.__decelerationVelocityY = (movedTop / timeOffset) * (1000 / 60);\n\n          // How much velocity is required to start the deceleration\n          var minVelocityToStartDeceleration =\n            self.options.paging || self.options.snapping ? 4 : 1;\n\n          // Verify that we have enough velocity to start deceleration\n          if (\n            Math.abs(self.__decelerationVelocityX) >\n              minVelocityToStartDeceleration ||\n            Math.abs(self.__decelerationVelocityY) >\n              minVelocityToStartDeceleration\n          ) {\n            // Deactivate pull-to-refresh when decelerating\n            if (!self.__refreshActive) {\n              self.__startDeceleration(timeStamp);\n            }\n          } else {\n            self.options.scrollingComplete();\n          }\n        } else {\n          self.options.scrollingComplete();\n        }\n      } else if (timeStamp - self.__lastTouchMove > 100) {\n        self.options.scrollingComplete();\n      }\n    }\n\n    // If this was a slower move it is per default non decelerated, but this\n    // still means that we want snap back to the bounds which is done here.\n    // This is placed outside the condition above to improve edge case stability\n    // e.g. touchend fired without enabled dragging. This should normally do not\n    // have modified the scroll positions or even showed the scrollbars though.\n    if (!self.__isDecelerating) {\n      if (self.__refreshActive && self.__refreshStart) {\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n        self.__publish(\n          self.__scrollLeft,\n          -self.__refreshHeight,\n          self.__zoomLevel,\n          true\n        );\n\n        if (self.__refreshStart) {\n          self.__refreshStart();\n        }\n      } else {\n        if (self.__interruptedAnimation || self.__isDragging) {\n          self.options.scrollingComplete();\n        }\n        self.scrollTo(\n          self.__scrollLeft,\n          self.__scrollTop,\n          true,\n          self.__zoomLevel\n        );\n\n        // Directly signalize deactivation (nothing todo on refresh?)\n        if (self.__refreshActive) {\n          self.__refreshActive = false;\n          if (self.__refreshDeactivate) {\n            self.__refreshDeactivate();\n          }\n        }\n      }\n    }\n\n    // Fully cleanup list\n    self.__positions.length = 0;\n  },\n\n  /*\n    ---------------------------------------------------------------------------\n      PRIVATE API\n    ---------------------------------------------------------------------------\n    */\n\n  /**\n   * Applies the scroll position to the content element\n   *\n   * @private\n   *\n   * @param left {Number} Left scroll position\n   * @param top {Number} Top scroll position\n   * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\n   */\n  __publish: function (left, top, zoom, animate) {\n    var self = this;\n\n    // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n    var wasAnimating = self.__isAnimating;\n    if (wasAnimating) {\n      stop(wasAnimating);\n      self.__isAnimating = false;\n    }\n\n    if (animate && self.options.animating) {\n      // Keep scheduled positions for scrollBy/zoomBy functionality\n      self.__scheduledLeft = left;\n      self.__scheduledTop = top;\n      self.__scheduledZoom = zoom;\n\n      var oldLeft = self.__scrollLeft;\n      var oldTop = self.__scrollTop;\n      var oldZoom = self.__zoomLevel;\n\n      var diffLeft = left - oldLeft;\n      var diffTop = top - oldTop;\n      var diffZoom = zoom - oldZoom;\n\n      var step = function (percent, now, render) {\n        if (render) {\n          self.__scrollLeft = oldLeft + diffLeft * percent;\n          self.__scrollTop = oldTop + diffTop * percent;\n          self.__zoomLevel = oldZoom + diffZoom * percent;\n\n          // Push values out\n          if (self.__callback) {\n            self.__callback(\n              self.__scrollLeft,\n              self.__scrollTop,\n              self.__zoomLevel\n            );\n          }\n        }\n      };\n\n      var verify = function (id) {\n        return self.__isAnimating === id;\n      };\n\n      var completed = function (\n        renderedFramesPerSecond,\n        animationId,\n        wasFinished\n      ) {\n        if (animationId === self.__isAnimating) {\n          self.__isAnimating = false;\n        }\n        if (self.__didDecelerationComplete || wasFinished) {\n          self.options.scrollingComplete();\n        }\n\n        if (self.options.zooming) {\n          self.__computeScrollMax();\n          if (self.__zoomComplete) {\n            self.__zoomComplete();\n            self.__zoomComplete = null;\n          }\n        }\n      };\n\n      // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n      self.__isAnimating = start(\n        step,\n        verify,\n        completed,\n        self.options.animationDuration,\n        wasAnimating ? easeOutCubic : easeInOutCubic\n      );\n    } else {\n      self.__scheduledLeft = self.__scrollLeft = left;\n      self.__scheduledTop = self.__scrollTop = top;\n      self.__scheduledZoom = self.__zoomLevel = zoom;\n\n      // Push values out\n      if (self.__callback) {\n        self.__callback(left, top, zoom);\n      }\n\n      // Fix max scroll ranges\n      if (self.options.zooming) {\n        self.__computeScrollMax();\n        if (self.__zoomComplete) {\n          self.__zoomComplete();\n          self.__zoomComplete = null;\n        }\n      }\n    }\n  },\n\n  /**\n   * Recomputes scroll minimum values based on client dimensions and content dimensions.\n   * @private\n   */\n  __computeScrollMax: function (zoomLevel) {\n    var self = this;\n\n    if (zoomLevel == null) {\n      zoomLevel = self.__zoomLevel;\n    }\n\n    self.__maxScrollLeft = Math.max(\n      self.__contentWidth * zoomLevel - self.__clientWidth,\n      0\n    );\n    self.__maxScrollTop = Math.max(\n      self.__contentHeight * zoomLevel - self.__clientHeight,\n      0\n    );\n  },\n\n  /*\n    ---------------------------------------------------------------------------\n      ANIMATION (DECELERATION) SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n  /**\n   * Called when a touch sequence end and the speed of the finger was high enough\n   * to switch into deceleration mode.\n   * @private\n   */\n  __startDeceleration: function (timeStamp) {\n    var self = this;\n\n    if (self.options.paging) {\n      var scrollLeft = Math.max(\n        Math.min(self.__scrollLeft, self.__maxScrollLeft),\n        0\n      );\n      var scrollTop = Math.max(\n        Math.min(self.__scrollTop, self.__maxScrollTop),\n        0\n      );\n      var clientWidth = self.__clientWidth;\n      var clientHeight = self.__clientHeight;\n\n      // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n      // Each page should have exactly the size of the client area.\n      self.__minDecelerationScrollLeft =\n        Math.floor(scrollLeft / clientWidth) * clientWidth;\n      self.__minDecelerationScrollTop =\n        Math.floor(scrollTop / clientHeight) * clientHeight;\n      self.__maxDecelerationScrollLeft =\n        Math.ceil(scrollLeft / clientWidth) * clientWidth;\n      self.__maxDecelerationScrollTop =\n        Math.ceil(scrollTop / clientHeight) * clientHeight;\n    } else {\n      self.__minDecelerationScrollLeft = 0;\n      self.__minDecelerationScrollTop = 0;\n      self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n      self.__maxDecelerationScrollTop = self.__maxScrollTop;\n    }\n\n    // Wrap class method\n    var step = function (percent, now, render) {\n      self.__stepThroughDeceleration(render);\n    };\n\n    // How much velocity is required to keep the deceleration running\n    var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\n\n    // Detect whether it's still worth to continue animating steps\n    // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n    var verify = function () {\n      var shouldContinue =\n        Math.abs(self.__decelerationVelocityX) >=\n          minVelocityToKeepDecelerating ||\n        Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\n      if (!shouldContinue) {\n        self.__didDecelerationComplete = true;\n      }\n      return shouldContinue;\n    };\n\n    var completed = function (\n      renderedFramesPerSecond,\n      animationId,\n      wasFinished\n    ) {\n      self.__isDecelerating = false;\n      if (self.__didDecelerationComplete) {\n        self.options.scrollingComplete();\n      }\n\n      // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n    };\n\n    // Start animation and switch on flag\n    self.__isDecelerating = start(step, verify, completed);\n  },\n\n  /**\n   * Called on every step of the animation\n   *\n   * @param {Function} [render] Whether to not render the current step, but keep it in memory only. Used internally only!\n   * @private\n   */\n  __stepThroughDeceleration: function (render) {\n    var self = this;\n\n    //\n    // COMPUTE NEXT SCROLL POSITION\n    //\n\n    // Add deceleration to scroll position\n    var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n    var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\n    //\n    // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n    //\n\n    if (!self.options.bouncing) {\n      var scrollLeftFixed = Math.max(\n        Math.min(self.__maxDecelerationScrollLeft, scrollLeft),\n        self.__minDecelerationScrollLeft\n      );\n      if (scrollLeftFixed !== scrollLeft) {\n        scrollLeft = scrollLeftFixed;\n        self.__decelerationVelocityX = 0;\n      }\n\n      var scrollTopFixed = Math.max(\n        Math.min(self.__maxDecelerationScrollTop, scrollTop),\n        self.__minDecelerationScrollTop\n      );\n      if (scrollTopFixed !== scrollTop) {\n        scrollTop = scrollTopFixed;\n        self.__decelerationVelocityY = 0;\n      }\n    }\n\n    //\n    // UPDATE SCROLL POSITION\n    //\n\n    if (render) {\n      self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n    } else {\n      self.__scrollLeft = scrollLeft;\n      self.__scrollTop = scrollTop;\n    }\n\n    //\n    // SLOW DOWN\n    //\n\n    // Slow down velocity on every iteration\n    if (!self.options.paging) {\n      // This is the factor applied to every iteration of the animation\n      // to slow down the process. This should emulate natural behavior where\n      // objects slow down when the initiator of the movement is removed\n      var frictionFactor = 0.95;\n\n      self.__decelerationVelocityX *= frictionFactor;\n      self.__decelerationVelocityY *= frictionFactor;\n    }\n\n    //\n    // BOUNCING SUPPORT\n    //\n\n    if (self.options.bouncing) {\n      var scrollOutsideX = 0;\n      var scrollOutsideY = 0;\n\n      // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n      var penetrationDeceleration = self.options.penetrationDeceleration;\n      var penetrationAcceleration = self.options.penetrationAcceleration;\n\n      // Check limits\n      if (scrollLeft < self.__minDecelerationScrollLeft) {\n        scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n      } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n        scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n      }\n\n      if (scrollTop < self.__minDecelerationScrollTop) {\n        scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n      } else if (scrollTop > self.__maxDecelerationScrollTop) {\n        scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n      }\n\n      // Slow down until slow enough, then flip back to snap position\n      if (scrollOutsideX !== 0) {\n        if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n          self.__decelerationVelocityX +=\n            scrollOutsideX * penetrationDeceleration;\n        } else {\n          self.__decelerationVelocityX =\n            scrollOutsideX * penetrationAcceleration;\n        }\n      }\n\n      if (scrollOutsideY !== 0) {\n        if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n          self.__decelerationVelocityY +=\n            scrollOutsideY * penetrationDeceleration;\n        } else {\n          self.__decelerationVelocityY =\n            scrollOutsideY * penetrationAcceleration;\n        }\n      }\n    }\n  },\n};\n\nexport default Scroller;\n"],"names":["global","window","running","counter","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","stop","id","cleared","start","stepCallback","verifyCallback","completedCallback","duration","easingMethod","Date","now","lastFrame","percent","dropCounter","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","value","easeOutCubic","pos","pow","easeInOutCubic","defaults","scrollingX","scrollingY","animating","animationDuration","bouncing","locking","paging","snapping","zooming","minZoom","maxZoom","speedMultiplier","scrollingComplete","penetrationDeceleration","penetrationAcceleration","Scroller","callback","options","this","__callback","Object","assign","prototype","i","o","l","h","u","_","v","M","m","p","g","T","D","S","L","Z","I","P","A","H","V","C","R","W","k","B","X","Y","G","O","q","F","J","K","N","U","$","setDimensions","clientWidth","clientHeight","contentWidth","contentHeight","self","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__computeScrollMax","scrollTo","__scrollLeft","__scrollTop","setPosition","left","top","__clientLeft","__clientTop","setSnapSize","width","height","__snapWidth","__snapHeight","activatePullToRefresh","activateCallback","deactivateCallback","startCallback","__refreshHeight","__refreshActivate","__refreshDeactivate","__refreshStart","triggerPullToRefresh","__publish","__zoomLevel","finishPullToRefresh","__refreshActive","getValues","zoom","getScrollMax","__maxScrollLeft","__maxScrollTop","zoomTo","level","animate","originLeft","originTop","Error","__zoomComplete","__isDecelerating","oldLevel","max","zoomBy","factor","__isTracking","[object Object]","scrollBy","startLeft","__isAnimating","__scheduledLeft","startTop","__scheduledTop","containsPoint","x","y","doMouseZoom","wheelDelta","timeStamp","pageX","pageY","change","doTouchStart","touches","length","valueOf","currentTouchLeft","currentTouchTop","__interruptedAnimation","isSingleTouch","abs","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__lastScale","__enableScrollX","__enableScrollY","__didDecelerationComplete","__isDragging","__isSingleTouch","__positions","doTouchMove","scale","positions","moveX","moveY","scrollLeft","scrollTop","currentTouchLeftRel","currentTouchTopRel","maxScrollLeft","maxScrollTop","splice","push","minimumTrackingForScroll","distanceX","distanceY","doTouchEnd","endPos","startPos","timeOffset","movedLeft","movedTop","__decelerationVelocityX","__decelerationVelocityY","minVelocityToStartDeceleration","__startDeceleration","nt","wasAnimating","__scheduledZoom","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","renderedFramesPerSecond","animationId","wasFinished","tt","zoomLevel","ut","__minDecelerationScrollLeft","floor","__minDecelerationScrollTop","__maxDecelerationScrollLeft","ceil","__maxDecelerationScrollTop","minVelocityToKeepDecelerating","__stepThroughDeceleration","shouldContinue","ct","scrollLeftFixed","scrollTopFixed","scrollOutsideX","scrollOutsideY"],"mappings":"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"}